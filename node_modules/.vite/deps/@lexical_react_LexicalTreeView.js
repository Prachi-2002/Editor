import {
  $generateHtmlFromNodes
} from "./chunk-ET2DMQHS.js";
import {
  $descendantsMatching,
  $findMatchingParent,
  addClassNamesToElement,
  mergeRegister,
  removeClassNamesFromElement
} from "./chunk-W2455ZJ2.js";
import {
  $applyNodeReplacement,
  $createParagraphNode,
  $createPoint,
  $getEditor,
  $getNearestNodeFromDOMNode,
  $getRoot,
  $getSelection,
  $isElementNode,
  $isLineBreakNode,
  $isNodeSelection,
  $isParagraphNode,
  $isRangeSelection,
  $isTextNode,
  $normalizeSelection,
  COMMAND_PRIORITY_CRITICAL,
  ElementNode,
  TEXT_TYPE_TO_FORMAT,
  createCommand,
  isCurrentlyReadOnlyMode,
  isHTMLAnchorElement,
  isHTMLElement,
  setDOMUnmanaged
} from "./chunk-HNFFVMPG.js";
import {
  require_jsx_runtime
} from "./chunk-KGVKXMSY.js";
import {
  require_react
} from "./chunk-A5RA4VRI.js";
import {
  __toESM
} from "./chunk-7D4SUZUM.js";

// node_modules/@lexical/link/LexicalLink.dev.mjs
var SUPPORTED_URL_PROTOCOLS = /* @__PURE__ */ new Set(["http:", "https:", "mailto:", "sms:", "tel:"]);
var LinkNode = class _LinkNode extends ElementNode {
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  static getType() {
    return "link";
  }
  static clone(node) {
    return new _LinkNode(node.__url, {
      rel: node.__rel,
      target: node.__target,
      title: node.__title
    }, node.__key);
  }
  constructor(url = "", attributes = {}, key) {
    super(key);
    const {
      target = null,
      rel = null,
      title = null
    } = attributes;
    this.__url = url;
    this.__target = target;
    this.__rel = rel;
    this.__title = title;
  }
  createDOM(config) {
    const element = document.createElement("a");
    element.href = this.sanitizeUrl(this.__url);
    if (this.__target !== null) {
      element.target = this.__target;
    }
    if (this.__rel !== null) {
      element.rel = this.__rel;
    }
    if (this.__title !== null) {
      element.title = this.__title;
    }
    addClassNamesToElement(element, config.theme.link);
    return element;
  }
  updateDOM(prevNode, anchor, config) {
    if (isHTMLAnchorElement(anchor)) {
      const url = this.__url;
      const target = this.__target;
      const rel = this.__rel;
      const title = this.__title;
      if (url !== prevNode.__url) {
        anchor.href = url;
      }
      if (target !== prevNode.__target) {
        if (target) {
          anchor.target = target;
        } else {
          anchor.removeAttribute("target");
        }
      }
      if (rel !== prevNode.__rel) {
        if (rel) {
          anchor.rel = rel;
        } else {
          anchor.removeAttribute("rel");
        }
      }
      if (title !== prevNode.__title) {
        if (title) {
          anchor.title = title;
        } else {
          anchor.removeAttribute("title");
        }
      }
    }
    return false;
  }
  static importDOM() {
    return {
      a: (node) => ({
        conversion: $convertAnchorElement,
        priority: 1
      })
    };
  }
  static importJSON(serializedNode) {
    return $createLinkNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);
  }
  sanitizeUrl(url) {
    try {
      const parsedUrl = new URL(url);
      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {
        return "about:blank";
      }
    } catch (_unused) {
      return url;
    }
    return url;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      rel: this.getRel(),
      target: this.getTarget(),
      title: this.getTitle(),
      url: this.getURL()
    };
  }
  getURL() {
    return this.getLatest().__url;
  }
  setURL(url) {
    const writable = this.getWritable();
    writable.__url = url;
    return writable;
  }
  getTarget() {
    return this.getLatest().__target;
  }
  setTarget(target) {
    const writable = this.getWritable();
    writable.__target = target;
    return writable;
  }
  getRel() {
    return this.getLatest().__rel;
  }
  setRel(rel) {
    const writable = this.getWritable();
    writable.__rel = rel;
    return writable;
  }
  getTitle() {
    return this.getLatest().__title;
  }
  setTitle(title) {
    const writable = this.getWritable();
    writable.__title = title;
    return writable;
  }
  insertNewAfter(_, restoreSelection = true) {
    const linkNode = $createLinkNode(this.__url, {
      rel: this.__rel,
      target: this.__target,
      title: this.__title
    });
    this.insertAfter(linkNode, restoreSelection);
    return linkNode;
  }
  canInsertTextBefore() {
    return false;
  }
  canInsertTextAfter() {
    return false;
  }
  canBeEmpty() {
    return false;
  }
  isInline() {
    return true;
  }
  extractWithChild(child, selection, destination) {
    if (!$isRangeSelection(selection)) {
      return false;
    }
    const anchorNode = selection.anchor.getNode();
    const focusNode = selection.focus.getNode();
    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;
  }
  isEmailURI() {
    return this.__url.startsWith("mailto:");
  }
  isWebSiteURI() {
    return this.__url.startsWith("https://") || this.__url.startsWith("http://");
  }
};
function $convertAnchorElement(domNode) {
  let node = null;
  if (isHTMLAnchorElement(domNode)) {
    const content = domNode.textContent;
    if (content !== null && content !== "" || domNode.children.length > 0) {
      node = $createLinkNode(domNode.getAttribute("href") || "", {
        rel: domNode.getAttribute("rel"),
        target: domNode.getAttribute("target"),
        title: domNode.getAttribute("title")
      });
    }
  }
  return {
    node
  };
}
function $createLinkNode(url = "", attributes) {
  return $applyNodeReplacement(new LinkNode(url, attributes));
}
function $isLinkNode(node) {
  return node instanceof LinkNode;
}
var TOGGLE_LINK_COMMAND = createCommand("TOGGLE_LINK_COMMAND");

// node_modules/@lexical/mark/LexicalMark.dev.mjs
var NO_IDS = [];
var MarkNode = class _MarkNode extends ElementNode {
  /** @internal */
  static getType() {
    return "mark";
  }
  static clone(node) {
    return new _MarkNode(node.__ids, node.__key);
  }
  static importDOM() {
    return null;
  }
  static importJSON(serializedNode) {
    return $createMarkNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setIDs(serializedNode.ids);
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      ids: this.getIDs()
    };
  }
  constructor(ids = NO_IDS, key) {
    super(key);
    this.__ids = ids;
  }
  createDOM(config) {
    const element = document.createElement("mark");
    addClassNamesToElement(element, config.theme.mark);
    if (this.__ids.length > 1) {
      addClassNamesToElement(element, config.theme.markOverlap);
    }
    return element;
  }
  updateDOM(prevNode, element, config) {
    const prevIDs = prevNode.__ids;
    const nextIDs = this.__ids;
    const prevIDsCount = prevIDs.length;
    const nextIDsCount = nextIDs.length;
    const overlapTheme = config.theme.markOverlap;
    if (prevIDsCount !== nextIDsCount) {
      if (prevIDsCount === 1) {
        if (nextIDsCount === 2) {
          addClassNamesToElement(element, overlapTheme);
        }
      } else if (nextIDsCount === 1) {
        removeClassNamesFromElement(element, overlapTheme);
      }
    }
    return false;
  }
  hasID(id) {
    return this.getIDs().includes(id);
  }
  getIDs() {
    return Array.from(this.getLatest().__ids);
  }
  setIDs(ids) {
    const self = this.getWritable();
    self.__ids = ids;
    return self;
  }
  addID(id) {
    const self = this.getWritable();
    return self.__ids.includes(id) ? self : self.setIDs([...self.__ids, id]);
  }
  deleteID(id) {
    const self = this.getWritable();
    const idx = self.__ids.indexOf(id);
    if (idx === -1) {
      return self;
    }
    const ids = Array.from(self.__ids);
    ids.splice(idx, 1);
    return self.setIDs(ids);
  }
  insertNewAfter(selection, restoreSelection = true) {
    const markNode = $createMarkNode(this.__ids);
    this.insertAfter(markNode, restoreSelection);
    return markNode;
  }
  canInsertTextBefore() {
    return false;
  }
  canInsertTextAfter() {
    return false;
  }
  canBeEmpty() {
    return false;
  }
  isInline() {
    return true;
  }
  extractWithChild(child, selection, destination) {
    if (!$isRangeSelection(selection) || destination === "html") {
      return false;
    }
    const anchor = selection.anchor;
    const focus = selection.focus;
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    const isBackward = selection.isBackward();
    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;
    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;
  }
  excludeFromCopy(destination) {
    return destination !== "clone";
  }
};
function $createMarkNode(ids = NO_IDS) {
  return $applyNodeReplacement(new MarkNode(ids));
}
function $isMarkNode(node) {
  return node instanceof MarkNode;
}

// node_modules/@lexical/table/LexicalTable.dev.mjs
var PIXEL_VALUE_REG_EXP = /^(\d+(?:\.\d+)?)px$/;
var COLUMN_WIDTH = 75;
var TableCellHeaderStates = {
  BOTH: 3,
  COLUMN: 2,
  NO_STATUS: 0,
  ROW: 1
};
var TableCellNode = class _TableCellNode extends ElementNode {
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  static getType() {
    return "tablecell";
  }
  static clone(node) {
    return new _TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);
  }
  afterCloneFrom(node) {
    super.afterCloneFrom(node);
    this.__rowSpan = node.__rowSpan;
    this.__backgroundColor = node.__backgroundColor;
  }
  static importDOM() {
    return {
      td: (node) => ({
        conversion: $convertTableCellNodeElement,
        priority: 0
      }),
      th: (node) => ({
        conversion: $convertTableCellNodeElement,
        priority: 0
      })
    };
  }
  static importJSON(serializedNode) {
    return $createTableCellNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setHeaderStyles(serializedNode.headerState).setColSpan(serializedNode.colSpan || 1).setRowSpan(serializedNode.rowSpan || 1).setWidth(serializedNode.width || void 0).setBackgroundColor(serializedNode.backgroundColor || null);
  }
  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {
    super(key);
    this.__colSpan = colSpan;
    this.__rowSpan = 1;
    this.__headerState = headerState;
    this.__width = width;
    this.__backgroundColor = null;
  }
  createDOM(config) {
    const element = document.createElement(this.getTag());
    if (this.__width) {
      element.style.width = `${this.__width}px`;
    }
    if (this.__colSpan > 1) {
      element.colSpan = this.__colSpan;
    }
    if (this.__rowSpan > 1) {
      element.rowSpan = this.__rowSpan;
    }
    if (this.__backgroundColor !== null) {
      element.style.backgroundColor = this.__backgroundColor;
    }
    addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);
    return element;
  }
  exportDOM(editor) {
    const output = super.exportDOM(editor);
    if (isHTMLElement(output.element)) {
      const element = output.element;
      element.setAttribute("data-temporary-table-cell-lexical-key", this.getKey());
      element.style.border = "1px solid black";
      if (this.__colSpan > 1) {
        element.colSpan = this.__colSpan;
      }
      if (this.__rowSpan > 1) {
        element.rowSpan = this.__rowSpan;
      }
      element.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;
      element.style.verticalAlign = "top";
      element.style.textAlign = "start";
      if (this.__backgroundColor === null && this.hasHeader()) {
        element.style.backgroundColor = "#f2f3f5";
      }
    }
    return output;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      backgroundColor: this.getBackgroundColor(),
      colSpan: this.__colSpan,
      headerState: this.__headerState,
      rowSpan: this.__rowSpan,
      width: this.getWidth()
    };
  }
  getColSpan() {
    return this.getLatest().__colSpan;
  }
  setColSpan(colSpan) {
    const self = this.getWritable();
    self.__colSpan = colSpan;
    return self;
  }
  getRowSpan() {
    return this.getLatest().__rowSpan;
  }
  setRowSpan(rowSpan) {
    const self = this.getWritable();
    self.__rowSpan = rowSpan;
    return self;
  }
  getTag() {
    return this.hasHeader() ? "th" : "td";
  }
  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {
    const self = this.getWritable();
    self.__headerState = headerState & mask | self.__headerState & ~mask;
    return self;
  }
  getHeaderStyles() {
    return this.getLatest().__headerState;
  }
  setWidth(width) {
    const self = this.getWritable();
    self.__width = width;
    return self;
  }
  getWidth() {
    return this.getLatest().__width;
  }
  getBackgroundColor() {
    return this.getLatest().__backgroundColor;
  }
  setBackgroundColor(newBackgroundColor) {
    const self = this.getWritable();
    self.__backgroundColor = newBackgroundColor;
    return self;
  }
  toggleHeaderStyle(headerStateToToggle) {
    const self = this.getWritable();
    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {
      self.__headerState -= headerStateToToggle;
    } else {
      self.__headerState += headerStateToToggle;
    }
    return self;
  }
  hasHeaderState(headerState) {
    return (this.getHeaderStyles() & headerState) === headerState;
  }
  hasHeader() {
    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;
  }
  updateDOM(prevNode) {
    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;
  }
  isShadowRoot() {
    return true;
  }
  collapseAtStart() {
    return true;
  }
  canBeEmpty() {
    return false;
  }
  canIndent() {
    return false;
  }
};
function $convertTableCellNodeElement(domNode) {
  const domNode_ = domNode;
  const nodeName = domNode.nodeName.toLowerCase();
  let width = void 0;
  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {
    width = parseFloat(domNode_.style.width);
  }
  const tableCellNode = $createTableCellNode(nodeName === "th" ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);
  tableCellNode.__rowSpan = domNode_.rowSpan;
  const backgroundColor = domNode_.style.backgroundColor;
  if (backgroundColor !== "") {
    tableCellNode.__backgroundColor = backgroundColor;
  }
  const style = domNode_.style;
  const textDecoration = (style && style.textDecoration || "").split(" ");
  const hasBoldFontWeight = style.fontWeight === "700" || style.fontWeight === "bold";
  const hasLinethroughTextDecoration = textDecoration.includes("line-through");
  const hasItalicFontStyle = style.fontStyle === "italic";
  const hasUnderlineTextDecoration = textDecoration.includes("underline");
  return {
    after: (childLexicalNodes) => {
      if (childLexicalNodes.length === 0) {
        childLexicalNodes.push($createParagraphNode());
      }
      return childLexicalNodes;
    },
    forChild: (lexicalNode, parentLexicalNode) => {
      if ($isTableCellNode(parentLexicalNode) && !$isElementNode(lexicalNode)) {
        const paragraphNode = $createParagraphNode();
        if ($isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === "\n") {
          return null;
        }
        if ($isTextNode(lexicalNode)) {
          if (hasBoldFontWeight) {
            lexicalNode.toggleFormat("bold");
          }
          if (hasLinethroughTextDecoration) {
            lexicalNode.toggleFormat("strikethrough");
          }
          if (hasItalicFontStyle) {
            lexicalNode.toggleFormat("italic");
          }
          if (hasUnderlineTextDecoration) {
            lexicalNode.toggleFormat("underline");
          }
        }
        paragraphNode.append(lexicalNode);
        return paragraphNode;
      }
      return lexicalNode;
    },
    node: tableCellNode
  };
}
function $createTableCellNode(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width) {
  return $applyNodeReplacement(new TableCellNode(headerState, colSpan, width));
}
function $isTableCellNode(node) {
  return node instanceof TableCellNode;
}
var INSERT_TABLE_COMMAND = createCommand("INSERT_TABLE_COMMAND");
var TableRowNode = class _TableRowNode extends ElementNode {
  /** @internal */
  static getType() {
    return "tablerow";
  }
  static clone(node) {
    return new _TableRowNode(node.__height, node.__key);
  }
  static importDOM() {
    return {
      tr: (node) => ({
        conversion: $convertTableRowElement,
        priority: 0
      })
    };
  }
  static importJSON(serializedNode) {
    return $createTableRowNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setHeight(serializedNode.height);
  }
  constructor(height, key) {
    super(key);
    this.__height = height;
  }
  exportJSON() {
    const height = this.getHeight();
    return {
      ...super.exportJSON(),
      ...height === void 0 ? void 0 : {
        height
      }
    };
  }
  createDOM(config) {
    const element = document.createElement("tr");
    if (this.__height) {
      element.style.height = `${this.__height}px`;
    }
    addClassNamesToElement(element, config.theme.tableRow);
    return element;
  }
  extractWithChild(child, selection, destination) {
    return destination === "html";
  }
  isShadowRoot() {
    return true;
  }
  setHeight(height) {
    const self = this.getWritable();
    self.__height = height;
    return self;
  }
  getHeight() {
    return this.getLatest().__height;
  }
  updateDOM(prevNode) {
    return prevNode.__height !== this.__height;
  }
  canBeEmpty() {
    return false;
  }
  canIndent() {
    return false;
  }
};
function $convertTableRowElement(domNode) {
  const domNode_ = domNode;
  let height = void 0;
  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {
    height = parseFloat(domNode_.style.height);
  }
  return {
    after: (children) => $descendantsMatching(children, $isTableCellNode),
    node: $createTableRowNode(height)
  };
}
function $createTableRowNode(height) {
  return $applyNodeReplacement(new TableRowNode(height));
}
function $isTableRowNode(node) {
  return node instanceof TableRowNode;
}
var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var documentMode = CAN_USE_DOM && "documentMode" in document ? document.documentMode : null;
var IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
CAN_USE_DOM && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
function $computeTableMap(tableNode, cellA, cellB) {
  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(tableNode, cellA, cellB);
  if (!(cellAValue !== null)) {
    throw Error(`Anchor not found in Table`);
  }
  if (!(cellBValue !== null)) {
    throw Error(`Focus not found in Table`);
  }
  return [tableMap, cellAValue, cellBValue];
}
function $computeTableMapSkipCellCheck(tableNode, cellA, cellB) {
  const tableMap = [];
  let cellAValue = null;
  let cellBValue = null;
  function getMapRow(i) {
    let row = tableMap[i];
    if (row === void 0) {
      tableMap[i] = row = [];
    }
    return row;
  }
  const gridChildren = tableNode.getChildren();
  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {
    const row = gridChildren[rowIdx];
    if (!$isTableRowNode(row)) {
      throw Error(`Expected TableNode children to be TableRowNode`);
    }
    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {
      if (!$isTableCellNode(cell)) {
        throw Error(`Expected TableRowNode children to be TableCellNode`);
      }
      const startMapRow = getMapRow(rowIdx);
      while (startMapRow[colIdx] !== void 0) {
        colIdx++;
      }
      const value = {
        cell,
        startColumn: colIdx,
        startRow: rowIdx
      };
      const {
        __rowSpan: rowSpan,
        __colSpan: colSpan
      } = cell;
      for (let j = 0; j < rowSpan; j++) {
        if (rowIdx + j >= gridChildren.length) {
          break;
        }
        const mapRow = getMapRow(rowIdx + j);
        for (let i = 0; i < colSpan; i++) {
          mapRow[colIdx + i] = value;
        }
      }
      if (cellA !== null && cellAValue === null && cellA.is(cell)) {
        cellAValue = value;
      }
      if (cellB !== null && cellBValue === null && cellB.is(cell)) {
        cellBValue = value;
      }
    }
  }
  return [tableMap, cellAValue, cellBValue];
}
function $getNodeTriplet(source) {
  let cell;
  if (source instanceof TableCellNode) {
    cell = source;
  } else if ("__type" in source) {
    const cell_ = $findMatchingParent(source, $isTableCellNode);
    if (!$isTableCellNode(cell_)) {
      throw Error(`Expected to find a parent TableCellNode`);
    }
    cell = cell_;
  } else {
    const cell_ = $findMatchingParent(source.getNode(), $isTableCellNode);
    if (!$isTableCellNode(cell_)) {
      throw Error(`Expected to find a parent TableCellNode`);
    }
    cell = cell_;
  }
  const row = cell.getParent();
  if (!$isTableRowNode(row)) {
    throw Error(`Expected TableCellNode to have a parent TableRowNode`);
  }
  const grid = row.getParent();
  if (!$isTableNode(grid)) {
    throw Error(`Expected TableRowNode to have a parent TableNode`);
  }
  return [cell, row, grid];
}
function $computeTableCellRectBoundary(map, cellAMap, cellBMap) {
  let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);
  let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);
  let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);
  let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);
  let exploredMinColumn = minColumn;
  let exploredMinRow = minRow;
  let exploredMaxColumn = minColumn;
  let exploredMaxRow = minRow;
  function expandBoundary(mapValue) {
    const {
      cell,
      startColumn: cellStartColumn,
      startRow: cellStartRow
    } = mapValue;
    minColumn = Math.min(minColumn, cellStartColumn);
    minRow = Math.min(minRow, cellStartRow);
    maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);
    maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);
  }
  while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {
    if (minColumn < exploredMinColumn) {
      const rowDiff = exploredMaxRow - exploredMinRow;
      const previousColumn = exploredMinColumn - 1;
      for (let i = 0; i <= rowDiff; i++) {
        expandBoundary(map[exploredMinRow + i][previousColumn]);
      }
      exploredMinColumn = previousColumn;
    }
    if (minRow < exploredMinRow) {
      const columnDiff = exploredMaxColumn - exploredMinColumn;
      const previousRow = exploredMinRow - 1;
      for (let i = 0; i <= columnDiff; i++) {
        expandBoundary(map[previousRow][exploredMinColumn + i]);
      }
      exploredMinRow = previousRow;
    }
    if (maxColumn > exploredMaxColumn) {
      const rowDiff = exploredMaxRow - exploredMinRow;
      const nextColumn = exploredMaxColumn + 1;
      for (let i = 0; i <= rowDiff; i++) {
        expandBoundary(map[exploredMinRow + i][nextColumn]);
      }
      exploredMaxColumn = nextColumn;
    }
    if (maxRow > exploredMaxRow) {
      const columnDiff = exploredMaxColumn - exploredMinColumn;
      const nextRow = exploredMaxRow + 1;
      for (let i = 0; i <= columnDiff; i++) {
        expandBoundary(map[nextRow][exploredMinColumn + i]);
      }
      exploredMaxRow = nextRow;
    }
  }
  return {
    maxColumn,
    maxRow,
    minColumn,
    minRow
  };
}
function $getTableCellNodeRect(tableCellNode) {
  const [cellNode, , gridNode] = $getNodeTriplet(tableCellNode);
  const rows = gridNode.getChildren();
  const rowCount = rows.length;
  const columnCount = rows[0].getChildren().length;
  const cellMatrix = new Array(rowCount);
  for (let i = 0; i < rowCount; i++) {
    cellMatrix[i] = new Array(columnCount);
  }
  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {
    const row = rows[rowIndex];
    const cells = row.getChildren();
    let columnIndex = 0;
    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {
      while (cellMatrix[rowIndex][columnIndex]) {
        columnIndex++;
      }
      const cell = cells[cellIndex];
      const rowSpan = cell.__rowSpan || 1;
      const colSpan = cell.__colSpan || 1;
      for (let i = 0; i < rowSpan; i++) {
        for (let j = 0; j < colSpan; j++) {
          cellMatrix[rowIndex + i][columnIndex + j] = cell;
        }
      }
      if (cellNode === cell) {
        return {
          colSpan,
          columnIndex,
          rowIndex,
          rowSpan
        };
      }
      columnIndex += colSpan;
    }
  }
  return null;
}
function $getCellNodes(tableSelection) {
  const [[anchorNode, anchorCell, anchorRow, anchorTable], [focusNode, focusCell, focusRow, focusTable]] = ["anchor", "focus"].map((k) => {
    const node = tableSelection[k].getNode();
    const cellNode = $findMatchingParent(node, $isTableCellNode);
    if (!$isTableCellNode(cellNode)) {
      throw Error(`Expected TableSelection ${k} to be (or a child of) TableCellNode, got key ${node.getKey()} of type ${node.getType()}`);
    }
    const rowNode = cellNode.getParent();
    if (!$isTableRowNode(rowNode)) {
      throw Error(`Expected TableSelection ${k} cell parent to be a TableRowNode`);
    }
    const tableNode = rowNode.getParent();
    if (!$isTableNode(tableNode)) {
      throw Error(`Expected TableSelection ${k} row parent to be a TableNode`);
    }
    return [node, cellNode, rowNode, tableNode];
  });
  if (!anchorTable.is(focusTable)) {
    throw Error(`Expected TableSelection anchor and focus to be in the same table`);
  }
  return {
    anchorCell,
    anchorNode,
    anchorRow,
    anchorTable,
    focusCell,
    focusNode,
    focusRow,
    focusTable
  };
}
var TableSelection = class _TableSelection {
  constructor(tableKey, anchor, focus) {
    this.anchor = anchor;
    this.focus = focus;
    anchor._selection = this;
    focus._selection = this;
    this._cachedNodes = null;
    this.dirty = false;
    this.tableKey = tableKey;
  }
  getStartEndPoints() {
    return [this.anchor, this.focus];
  }
  /**
   * {@link $createTableSelection} unfortunately makes it very easy to create
   * nonsense selections, so we have a method to see if the selection probably
   * makes sense.
   *
   * @returns true if the TableSelection is (probably) valid
   */
  isValid() {
    return this.tableKey !== "root" && this.anchor.key !== "root" && this.anchor.type === "element" && this.focus.key !== "root" && this.focus.type === "element";
  }
  /**
   * Returns whether the Selection is "backwards", meaning the focus
   * logically precedes the anchor in the EditorState.
   * @returns true if the Selection is backwards, false otherwise.
   */
  isBackward() {
    return this.focus.isBefore(this.anchor);
  }
  getCachedNodes() {
    return this._cachedNodes;
  }
  setCachedNodes(nodes) {
    this._cachedNodes = nodes;
  }
  is(selection) {
    return $isTableSelection(selection) && this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);
  }
  set(tableKey, anchorCellKey, focusCellKey) {
    this.dirty = this.dirty || tableKey !== this.tableKey || anchorCellKey !== this.anchor.key || focusCellKey !== this.focus.key;
    this.tableKey = tableKey;
    this.anchor.key = anchorCellKey;
    this.focus.key = focusCellKey;
    this._cachedNodes = null;
  }
  clone() {
    return new _TableSelection(this.tableKey, $createPoint(this.anchor.key, this.anchor.offset, this.anchor.type), $createPoint(this.focus.key, this.focus.offset, this.focus.type));
  }
  isCollapsed() {
    return false;
  }
  extract() {
    return this.getNodes();
  }
  insertRawText(text) {
  }
  insertText() {
  }
  /**
   * Returns whether the provided TextFormatType is present on the Selection.
   * This will be true if any paragraph in table cells has the specified format.
   *
   * @param type the TextFormatType to check for.
   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
   */
  hasFormat(type) {
    let format = 0;
    const cellNodes = this.getNodes().filter($isTableCellNode);
    cellNodes.forEach((cellNode) => {
      const paragraph = cellNode.getFirstChild();
      if ($isParagraphNode(paragraph)) {
        format |= paragraph.getTextFormat();
      }
    });
    const formatFlag = TEXT_TYPE_TO_FORMAT[type];
    return (format & formatFlag) !== 0;
  }
  insertNodes(nodes) {
    const focusNode = this.focus.getNode();
    if (!$isElementNode(focusNode)) {
      throw Error(`Expected TableSelection focus to be an ElementNode`);
    }
    const selection = $normalizeSelection(focusNode.select(0, focusNode.getChildrenSize()));
    selection.insertNodes(nodes);
  }
  // TODO Deprecate this method. It's confusing when used with colspan|rowspan
  getShape() {
    const {
      anchorCell,
      focusCell
    } = $getCellNodes(this);
    const anchorCellNodeRect = $getTableCellNodeRect(anchorCell);
    if (!(anchorCellNodeRect !== null)) {
      throw Error(`getCellRect: expected to find AnchorNode`);
    }
    const focusCellNodeRect = $getTableCellNodeRect(focusCell);
    if (!(focusCellNodeRect !== null)) {
      throw Error(`getCellRect: expected to find focusCellNode`);
    }
    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);
    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);
    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);
    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);
    return {
      fromX: Math.min(startX, stopX),
      fromY: Math.min(startY, stopY),
      toX: Math.max(startX, stopX),
      toY: Math.max(startY, stopY)
    };
  }
  getNodes() {
    if (!this.isValid()) {
      return [];
    }
    const cachedNodes = this._cachedNodes;
    if (cachedNodes !== null) {
      return cachedNodes;
    }
    const {
      anchorTable: tableNode,
      anchorCell,
      focusCell
    } = $getCellNodes(this);
    const focusCellGrid = focusCell.getParents()[1];
    if (focusCellGrid !== tableNode) {
      if (!tableNode.isParentOf(focusCell)) {
        const gridParent = tableNode.getParent();
        if (!(gridParent != null)) {
          throw Error(`Expected gridParent to have a parent`);
        }
        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());
      } else {
        const focusCellParent = focusCellGrid.getParent();
        if (!(focusCellParent != null)) {
          throw Error(`Expected focusCellParent to have a parent`);
        }
        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());
      }
      return this.getNodes();
    }
    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);
    const {
      minColumn,
      maxColumn,
      minRow,
      maxRow
    } = $computeTableCellRectBoundary(map, cellAMap, cellBMap);
    const nodeMap = /* @__PURE__ */ new Map([[tableNode.getKey(), tableNode]]);
    let lastRow = null;
    for (let i = minRow; i <= maxRow; i++) {
      for (let j = minColumn; j <= maxColumn; j++) {
        const {
          cell
        } = map[i][j];
        const currentRow = cell.getParent();
        if (!$isTableRowNode(currentRow)) {
          throw Error(`Expected TableCellNode parent to be a TableRowNode`);
        }
        if (currentRow !== lastRow) {
          nodeMap.set(currentRow.getKey(), currentRow);
          lastRow = currentRow;
        }
        if (!nodeMap.has(cell.getKey())) {
          $visitRecursively(cell, (childNode) => {
            nodeMap.set(childNode.getKey(), childNode);
          });
        }
      }
    }
    const nodes = Array.from(nodeMap.values());
    if (!isCurrentlyReadOnlyMode()) {
      this._cachedNodes = nodes;
    }
    return nodes;
  }
  getTextContent() {
    const nodes = this.getNodes().filter((node) => $isTableCellNode(node));
    let textContent = "";
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      const row = node.__parent;
      const nextRow = (nodes[i + 1] || {}).__parent;
      textContent += node.getTextContent() + (nextRow !== row ? "\n" : "	");
    }
    return textContent;
  }
};
function $isTableSelection(x) {
  return x instanceof TableSelection;
}
function $visitRecursively(node, $visit) {
  const stack = [[node]];
  for (let currentArray = stack.at(-1); currentArray !== void 0 && stack.length > 0; currentArray = stack.at(-1)) {
    const currentNode = currentArray.pop();
    if (currentNode === void 0) {
      stack.pop();
    } else if ($visit(currentNode) !== false && $isElementNode(currentNode)) {
      stack.push(currentNode.getChildren());
    }
  }
}
function $findParentTableCellNodeInTable(tableNode, node) {
  for (let currentNode = node, lastTableCellNode = null; currentNode !== null; currentNode = currentNode.getParent()) {
    if (tableNode.is(currentNode)) {
      return lastTableCellNode;
    } else if ($isTableCellNode(currentNode)) {
      lastTableCellNode = currentNode;
    }
  }
  return null;
}
function $getNearestTableCellInTableFromDOMNode(tableNode, startingDOM, editorState) {
  return $findParentTableCellNodeInTable(tableNode, $getNearestNodeFromDOMNode(startingDOM, editorState));
}
function updateColgroup(dom, config, colCount, colWidths) {
  const colGroup = dom.querySelector("colgroup");
  if (!colGroup) {
    return;
  }
  const cols = [];
  for (let i = 0; i < colCount; i++) {
    const col = document.createElement("col");
    const width = colWidths && colWidths[i];
    if (width) {
      col.style.width = `${width}px`;
    }
    cols.push(col);
  }
  colGroup.replaceChildren(...cols);
}
function setRowStriping(dom, config, rowStriping) {
  if (rowStriping) {
    addClassNamesToElement(dom, config.theme.tableRowStriping);
    dom.setAttribute("data-lexical-row-striping", "true");
  } else {
    removeClassNamesFromElement(dom, config.theme.tableRowStriping);
    dom.removeAttribute("data-lexical-row-striping");
  }
}
var scrollableEditors = /* @__PURE__ */ new WeakSet();
function $isScrollableTablesActive(editor = $getEditor()) {
  return scrollableEditors.has(editor);
}
var TableNode = class _TableNode extends ElementNode {
  /** @internal */
  static getType() {
    return "table";
  }
  getColWidths() {
    const self = this.getLatest();
    return self.__colWidths;
  }
  setColWidths(colWidths) {
    const self = this.getWritable();
    self.__colWidths = colWidths !== void 0 && true ? Object.freeze(colWidths) : colWidths;
    return self;
  }
  static clone(node) {
    return new _TableNode(node.__key);
  }
  afterCloneFrom(prevNode) {
    super.afterCloneFrom(prevNode);
    this.__colWidths = prevNode.__colWidths;
    this.__rowStriping = prevNode.__rowStriping;
  }
  static importDOM() {
    return {
      table: (_node) => ({
        conversion: $convertTableElement,
        priority: 1
      })
    };
  }
  static importJSON(serializedNode) {
    return $createTableNode().updateFromJSON(serializedNode);
  }
  updateFromJSON(serializedNode) {
    return super.updateFromJSON(serializedNode).setRowStriping(serializedNode.rowStriping || false).setColWidths(serializedNode.colWidths);
  }
  constructor(key) {
    super(key);
    this.__rowStriping = false;
  }
  exportJSON() {
    return {
      ...super.exportJSON(),
      colWidths: this.getColWidths(),
      rowStriping: this.__rowStriping ? this.__rowStriping : void 0
    };
  }
  extractWithChild(child, selection, destination) {
    return destination === "html";
  }
  getDOMSlot(element) {
    const tableElement = element.nodeName !== "TABLE" && element.querySelector("table") || element;
    if (!(tableElement.nodeName === "TABLE")) {
      throw Error(`TableNode.getDOMSlot: createDOM() did not return a table`);
    }
    return super.getDOMSlot(tableElement).withAfter(tableElement.querySelector("colgroup"));
  }
  createDOM(config, editor) {
    const tableElement = document.createElement("table");
    const colGroup = document.createElement("colgroup");
    tableElement.appendChild(colGroup);
    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());
    setDOMUnmanaged(colGroup);
    addClassNamesToElement(tableElement, config.theme.table);
    if (this.__rowStriping) {
      setRowStriping(tableElement, config, true);
    }
    if ($isScrollableTablesActive(editor)) {
      const wrapperElement = document.createElement("div");
      const classes = config.theme.tableScrollableWrapper;
      if (classes) {
        addClassNamesToElement(wrapperElement, classes);
      } else {
        wrapperElement.style.cssText = "overflow-x: auto;";
      }
      wrapperElement.appendChild(tableElement);
      return wrapperElement;
    }
    return tableElement;
  }
  updateDOM(prevNode, dom, config) {
    if (prevNode.__rowStriping !== this.__rowStriping) {
      setRowStriping(dom, config, this.__rowStriping);
    }
    updateColgroup(dom, config, this.getColumnCount(), this.getColWidths());
    return false;
  }
  exportDOM(editor) {
    const superExport = super.exportDOM(editor);
    const {
      element
    } = superExport;
    return {
      after: (tableElement) => {
        if (superExport.after) {
          tableElement = superExport.after(tableElement);
        }
        if (isHTMLElement(tableElement) && tableElement.nodeName !== "TABLE") {
          tableElement = tableElement.querySelector("table");
        }
        if (!isHTMLElement(tableElement)) {
          return null;
        }
        const [tableMap] = $computeTableMapSkipCellCheck(this, null, null);
        const cellValues = /* @__PURE__ */ new Map();
        for (const mapRow of tableMap) {
          for (const mapValue of mapRow) {
            const key = mapValue.cell.getKey();
            if (!cellValues.has(key)) {
              cellValues.set(key, {
                colSpan: mapValue.cell.getColSpan(),
                startColumn: mapValue.startColumn
              });
            }
          }
        }
        const knownColumns = /* @__PURE__ */ new Set();
        for (const cellDOM of tableElement.querySelectorAll(":scope > tr > [data-temporary-table-cell-lexical-key]")) {
          const key = cellDOM.getAttribute("data-temporary-table-cell-lexical-key");
          if (key) {
            const cellSpan = cellValues.get(key);
            cellDOM.removeAttribute("data-temporary-table-cell-lexical-key");
            if (cellSpan) {
              cellValues.delete(key);
              for (let i = 0; i < cellSpan.colSpan; i++) {
                knownColumns.add(i + cellSpan.startColumn);
              }
            }
          }
        }
        const colGroup = tableElement.querySelector(":scope > colgroup");
        if (colGroup) {
          const cols = Array.from(tableElement.querySelectorAll(":scope > colgroup > col")).filter((dom, i) => knownColumns.has(i));
          colGroup.replaceChildren(...cols);
        }
        const rows = tableElement.querySelectorAll(":scope > tr");
        if (rows.length > 0) {
          const tBody = document.createElement("tbody");
          for (const row of rows) {
            tBody.appendChild(row);
          }
          tableElement.append(tBody);
        }
        return tableElement;
      },
      element: isHTMLElement(element) && element.nodeName !== "TABLE" ? element.querySelector("table") : element
    };
  }
  canBeEmpty() {
    return false;
  }
  isShadowRoot() {
    return true;
  }
  getCordsFromCellNode(tableCellNode, table) {
    const {
      rows,
      domRows
    } = table;
    for (let y = 0; y < rows; y++) {
      const row = domRows[y];
      if (row == null) {
        continue;
      }
      for (let x = 0; x < row.length; x++) {
        const cell = row[x];
        if (cell == null) {
          continue;
        }
        const {
          elem
        } = cell;
        const cellNode = $getNearestTableCellInTableFromDOMNode(this, elem);
        if (cellNode !== null && tableCellNode.is(cellNode)) {
          return {
            x,
            y
          };
        }
      }
    }
    throw new Error("Cell not found in table.");
  }
  getDOMCellFromCords(x, y, table) {
    const {
      domRows
    } = table;
    const row = domRows[y];
    if (row == null) {
      return null;
    }
    const index = x < row.length ? x : row.length - 1;
    const cell = row[index];
    if (cell == null) {
      return null;
    }
    return cell;
  }
  getDOMCellFromCordsOrThrow(x, y, table) {
    const cell = this.getDOMCellFromCords(x, y, table);
    if (!cell) {
      throw new Error("Cell not found at cords.");
    }
    return cell;
  }
  getCellNodeFromCords(x, y, table) {
    const cell = this.getDOMCellFromCords(x, y, table);
    if (cell == null) {
      return null;
    }
    const node = $getNearestNodeFromDOMNode(cell.elem);
    if ($isTableCellNode(node)) {
      return node;
    }
    return null;
  }
  getCellNodeFromCordsOrThrow(x, y, table) {
    const node = this.getCellNodeFromCords(x, y, table);
    if (!node) {
      throw new Error("Node at cords not TableCellNode.");
    }
    return node;
  }
  getRowStriping() {
    return Boolean(this.getLatest().__rowStriping);
  }
  setRowStriping(newRowStriping) {
    const self = this.getWritable();
    self.__rowStriping = newRowStriping;
    return self;
  }
  canSelectBefore() {
    return true;
  }
  canIndent() {
    return false;
  }
  getColumnCount() {
    const firstRow = this.getFirstChild();
    if (!firstRow) {
      return 0;
    }
    let columnCount = 0;
    firstRow.getChildren().forEach((cell) => {
      if ($isTableCellNode(cell)) {
        columnCount += cell.getColSpan();
      }
    });
    return columnCount;
  }
};
function $convertTableElement(domNode) {
  const tableNode = $createTableNode();
  if (domNode.hasAttribute("data-lexical-row-striping")) {
    tableNode.setRowStriping(true);
  }
  const colGroup = domNode.querySelector(":scope > colgroup");
  if (colGroup) {
    let columns = [];
    for (const col of colGroup.querySelectorAll(":scope > col")) {
      let width = col.style.width || "";
      if (!PIXEL_VALUE_REG_EXP.test(width)) {
        width = col.getAttribute("width") || "";
        if (!/^\d+$/.test(width)) {
          columns = void 0;
          break;
        }
      }
      columns.push(parseFloat(width));
    }
    if (columns) {
      tableNode.setColWidths(columns);
    }
  }
  return {
    after: (children) => $descendantsMatching(children, $isTableRowNode),
    node: tableNode
  };
}
function $createTableNode() {
  return $applyNodeReplacement(new TableNode());
}
function $isTableNode(node) {
  return node instanceof TableNode;
}

// node_modules/@lexical/devtools-core/LexicalDevtoolsCore.dev.mjs
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({
  "	": "\\t",
  "\n": "\\n"
});
var NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join("|"), "g");
var SYMBOLS = Object.freeze({
  ancestorHasNextSibling: "|",
  ancestorIsLastChild: " ",
  hasNextSibling: "├",
  isLastChild: "└",
  selectedChar: "^",
  selectedLine: ">"
});
var FORMAT_PREDICATES = [(node) => node.hasFormat("bold") && "Bold", (node) => node.hasFormat("code") && "Code", (node) => node.hasFormat("italic") && "Italic", (node) => node.hasFormat("strikethrough") && "Strikethrough", (node) => node.hasFormat("subscript") && "Subscript", (node) => node.hasFormat("superscript") && "Superscript", (node) => node.hasFormat("underline") && "Underline"];
var FORMAT_PREDICATES_PARAGRAPH = [(node) => node.hasTextFormat("bold") && "Bold", (node) => node.hasTextFormat("code") && "Code", (node) => node.hasTextFormat("italic") && "Italic", (node) => node.hasTextFormat("strikethrough") && "Strikethrough", (node) => node.hasTextFormat("subscript") && "Subscript", (node) => node.hasTextFormat("superscript") && "Superscript", (node) => node.hasTextFormat("underline") && "Underline"];
var DETAIL_PREDICATES = [(node) => node.isDirectionless() && "Directionless", (node) => node.isUnmergeable() && "Unmergeable"];
var MODE_PREDICATES = [(node) => node.isToken() && "Token", (node) => node.isSegmented() && "Segmented"];
function generateContent(editor, commandsLog, exportDOM, customPrintNode, obfuscateText = false) {
  const editorState = editor.getEditorState();
  const editorConfig = editor._config;
  const compositionKey = editor._compositionKey;
  const editable = editor._editable;
  if (exportDOM) {
    let htmlString = "";
    editorState.read(() => {
      htmlString = printPrettyHTML($generateHtmlFromNodes(editor));
    });
    return htmlString;
  }
  let res = " root\n";
  const selectionString = editorState.read(() => {
    const selection = $getSelection();
    visitTree($getRoot(), (node, indent) => {
      const nodeKey = node.getKey();
      const nodeKeyDisplay = `(${nodeKey})`;
      const typeDisplay = node.getType() || "";
      const isSelected = node.isSelected();
      res += `${isSelected ? SYMBOLS.selectedLine : " "} ${indent.join(" ")} ${nodeKeyDisplay} ${typeDisplay} ${printNode(node, customPrintNode, obfuscateText)}
`;
      res += $printSelectedCharsLine({
        indent,
        isSelected,
        node,
        nodeKeyDisplay,
        selection,
        typeDisplay
      });
    });
    return selection === null ? ": null" : $isRangeSelection(selection) ? printRangeSelection(selection) : $isTableSelection(selection) ? printTableSelection(selection) : printNodeSelection(selection);
  });
  res += "\n selection" + selectionString;
  res += "\n\n commands:";
  if (commandsLog.length) {
    for (const {
      index,
      type,
      payload
    } of commandsLog) {
      res += `
  └ ${index}. { type: ${type}, payload: ${payload instanceof Event ? payload.constructor.name : payload} }`;
    }
  } else {
    res += "\n  └ None dispatched.";
  }
  const {
    version
  } = editor.constructor;
  res += `

 editor${version ? ` (v${version})` : ""}:`;
  res += `
  └ namespace ${editorConfig.namespace}`;
  if (compositionKey !== null) {
    res += `
  └ compositionKey ${compositionKey}`;
  }
  res += `
  └ editable ${String(editable)}`;
  return res;
}
function printRangeSelection(selection) {
  let res = "";
  const formatText = printFormatProperties(selection);
  res += `: range ${formatText !== "" ? `{ ${formatText} }` : ""} ${selection.style !== "" ? `{ style: ${selection.style} } ` : ""}`;
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorOffset = anchor.offset;
  const focusOffset = focus.offset;
  res += `
  ├ anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? "null" : anchorOffset}, type: ${anchor.type} }`;
  res += `
  └ focus { key: ${focus.key}, offset: ${focusOffset === null ? "null" : focusOffset}, type: ${focus.type} }`;
  return res;
}
function printNodeSelection(selection) {
  if (!$isNodeSelection(selection)) {
    return "";
  }
  return `: node
  └ [${Array.from(selection._nodes).join(", ")}]`;
}
function printTableSelection(selection) {
  return `: table
  └ { table: ${selection.tableKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;
}
function visitTree(currentNode, visitor, indent = []) {
  const childNodes = currentNode.getChildren();
  const childNodesLength = childNodes.length;
  childNodes.forEach((childNode, i) => {
    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));
    if ($isElementNode(childNode)) {
      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));
    }
  });
}
function normalize(text, obfuscateText = false) {
  const textToPrint = Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, "g"), String(value)), text);
  if (obfuscateText) {
    return textToPrint.replace(/[^\s]/g, "*");
  }
  return textToPrint;
}
function printNode(node, customPrintNode, obfuscateText = false) {
  const customPrint = customPrintNode ? customPrintNode(node, obfuscateText) : void 0;
  if (customPrint !== void 0 && customPrint.length > 0) {
    return customPrint;
  }
  if ($isTextNode(node)) {
    const text = node.getTextContent();
    const title = text.length === 0 ? "(empty)" : `"${normalize(text, obfuscateText)}"`;
    const properties = printAllTextNodeProperties(node);
    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(" ").trim();
  } else if ($isLinkNode(node)) {
    const link = node.getURL();
    const title = link.length === 0 ? "(empty)" : `"${normalize(link, obfuscateText)}"`;
    const properties = printAllLinkNodeProperties(node);
    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(" ").trim();
  } else if ($isMarkNode(node)) {
    return `ids: [ ${node.getIDs().join(", ")} ]`;
  } else if ($isParagraphNode(node)) {
    const formatText = printTextFormatProperties(node);
    let paragraphData = formatText !== "" ? `{ ${formatText} }` : "";
    paragraphData += node.__style ? `(${node.__style})` : "";
    return paragraphData;
  } else {
    return "";
  }
}
function printTextFormatProperties(nodeOrSelection) {
  let str = FORMAT_PREDICATES_PARAGRAPH.map((predicate) => predicate(nodeOrSelection)).filter(Boolean).join(", ").toLocaleLowerCase();
  if (str !== "") {
    str = "format: " + str;
  }
  return str;
}
function printAllTextNodeProperties(node) {
  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node)].filter(Boolean).join(", ");
}
function printAllLinkNodeProperties(node) {
  return [printTargetProperties(node), printRelProperties(node), printTitleProperties(node)].filter(Boolean).join(", ");
}
function printDetailProperties(nodeOrSelection) {
  let str = DETAIL_PREDICATES.map((predicate) => predicate(nodeOrSelection)).filter(Boolean).join(", ").toLocaleLowerCase();
  if (str !== "") {
    str = "detail: " + str;
  }
  return str;
}
function printModeProperties(nodeOrSelection) {
  let str = MODE_PREDICATES.map((predicate) => predicate(nodeOrSelection)).filter(Boolean).join(", ").toLocaleLowerCase();
  if (str !== "") {
    str = "mode: " + str;
  }
  return str;
}
function printFormatProperties(nodeOrSelection) {
  let str = FORMAT_PREDICATES.map((predicate) => predicate(nodeOrSelection)).filter(Boolean).join(", ").toLocaleLowerCase();
  if (str !== "") {
    str = "format: " + str;
  }
  return str;
}
function printTargetProperties(node) {
  let str = node.getTarget();
  if (str != null) {
    str = "target: " + str;
  }
  return str;
}
function printRelProperties(node) {
  let str = node.getRel();
  if (str != null) {
    str = "rel: " + str;
  }
  return str;
}
function printTitleProperties(node) {
  let str = node.getTitle();
  if (str != null) {
    str = "title: " + str;
  }
  return str;
}
function $printSelectedCharsLine({
  indent,
  isSelected,
  node,
  nodeKeyDisplay,
  selection,
  typeDisplay
}) {
  if (!$isTextNode(node) || !$isRangeSelection(selection) || !isSelected || $isElementNode(node)) {
    return "";
  }
  const anchor = selection.anchor;
  const focus = selection.focus;
  if (node.getTextContent() === "" || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {
    return "";
  }
  const [start, end] = $getSelectionStartEnd(node, selection);
  if (start === end) {
    return "";
  }
  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;
  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];
  const unselectedChars = Array(start + 1).fill(" ");
  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);
  const paddingLength = typeDisplay.length + 2;
  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(" ");
  return [SYMBOLS.selectedLine, indentionChars.join(" "), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join("")].join(" ") + "\n";
}
function printPrettyHTML(str) {
  const div = document.createElement("div");
  div.innerHTML = str.trim();
  return prettifyHTML(div, 0).innerHTML;
}
function prettifyHTML(node, level) {
  const indentBefore = new Array(level++ + 1).join("  ");
  const indentAfter = new Array(level - 1).join("  ");
  let textNode;
  for (let i = 0; i < node.children.length; i++) {
    textNode = document.createTextNode("\n" + indentBefore);
    node.insertBefore(textNode, node.children[i]);
    prettifyHTML(node.children[i], level);
    if (node.lastElementChild === node.children[i]) {
      textNode = document.createTextNode("\n" + indentAfter);
      node.appendChild(textNode);
    }
  }
  return node;
}
function $getSelectionStartEnd(node, selection) {
  const anchorAndFocus = selection.getStartEndPoints();
  if ($isNodeSelection(selection) || anchorAndFocus === null) {
    return [-1, -1];
  }
  const [anchor, focus] = anchorAndFocus;
  const textContent = node.getTextContent();
  const textLength = textContent.length;
  let start = -1;
  let end = -1;
  if (anchor.type === "text" && focus.type === "text") {
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {
      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];
    } else if (node === anchorNode) {
      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];
    } else if (node === focusNode) {
      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];
    } else {
      [start, end] = [0, textLength];
    }
  }
  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;
  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;
  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];
}
var LARGE_EDITOR_STATE_SIZE = 1e3;
var TreeView = (0, import_react.forwardRef)(function TreeViewWrapped({
  treeTypeButtonClassName,
  timeTravelButtonClassName,
  timeTravelPanelSliderClassName,
  timeTravelPanelButtonClassName,
  viewClassName,
  timeTravelPanelClassName,
  editorState,
  setEditorState,
  setEditorReadOnly,
  generateContent: generateContent2
}, ref) {
  const [timeStampedEditorStates, setTimeStampedEditorStates] = (0, import_react.useState)([]);
  const [content, setContent] = (0, import_react.useState)("");
  const [timeTravelEnabled, setTimeTravelEnabled] = (0, import_react.useState)(false);
  const [showExportDOM, setShowExportDOM] = (0, import_react.useState)(false);
  const playingIndexRef = (0, import_react.useRef)(0);
  const inputRef = (0, import_react.useRef)(null);
  const [isPlaying, setIsPlaying] = (0, import_react.useState)(false);
  const [isLimited, setIsLimited] = (0, import_react.useState)(false);
  const [showLimited, setShowLimited] = (0, import_react.useState)(false);
  const lastEditorStateRef = (0, import_react.useRef)();
  const lastGenerationID = (0, import_react.useRef)(0);
  const generateTree = (0, import_react.useCallback)((exportDOM) => {
    const myID = ++lastGenerationID.current;
    generateContent2(exportDOM).then((treeText) => {
      if (myID === lastGenerationID.current) {
        setContent(treeText);
      }
    }).catch((err) => {
      if (myID === lastGenerationID.current) {
        setContent(`Error rendering tree: ${err.message}

Stack:
${err.stack}`);
      }
    });
  }, [generateContent2]);
  (0, import_react.useEffect)(() => {
    if (!showLimited && editorState._nodeMap.size > LARGE_EDITOR_STATE_SIZE) {
      setIsLimited(true);
      if (!showLimited) {
        return;
      }
    }
    if (lastEditorStateRef.current !== editorState) {
      lastEditorStateRef.current = editorState;
      generateTree(showExportDOM);
      if (!timeTravelEnabled) {
        setTimeStampedEditorStates((currentEditorStates) => [...currentEditorStates, [Date.now(), editorState]]);
      }
    }
  }, [editorState, generateTree, showExportDOM, showLimited, timeTravelEnabled]);
  const totalEditorStates = timeStampedEditorStates.length;
  (0, import_react.useEffect)(() => {
    if (isPlaying) {
      let timeoutId;
      const play = () => {
        const currentIndex = playingIndexRef.current;
        if (currentIndex === totalEditorStates - 1) {
          setIsPlaying(false);
          return;
        }
        const currentTime = timeStampedEditorStates[currentIndex][0];
        const nextTime = timeStampedEditorStates[currentIndex + 1][0];
        const timeDiff = nextTime - currentTime;
        timeoutId = setTimeout(() => {
          playingIndexRef.current++;
          const index = playingIndexRef.current;
          const input = inputRef.current;
          if (input !== null) {
            input.value = String(index);
          }
          setEditorState(timeStampedEditorStates[index][1]);
          play();
        }, timeDiff);
      };
      play();
      return () => {
        clearTimeout(timeoutId);
      };
    }
  }, [timeStampedEditorStates, isPlaying, totalEditorStates, setEditorState]);
  const handleExportModeToggleClick = () => {
    generateTree(!showExportDOM);
    setShowExportDOM(!showExportDOM);
  };
  return (0, import_jsx_runtime.jsxs)("div", {
    className: viewClassName,
    children: [!showLimited && isLimited ? (0, import_jsx_runtime.jsxs)("div", {
      style: {
        padding: 20
      },
      children: [(0, import_jsx_runtime.jsx)("span", {
        style: {
          marginRight: 20
        },
        children: "Detected large EditorState, this can impact debugging performance."
      }), (0, import_jsx_runtime.jsx)("button", {
        onClick: () => {
          setShowLimited(true);
        },
        style: {
          background: "transparent",
          border: "1px solid white",
          color: "white",
          cursor: "pointer",
          padding: 5
        },
        children: "Show full tree"
      })]
    }) : null, !showLimited ? (0, import_jsx_runtime.jsx)("button", {
      onClick: () => handleExportModeToggleClick(),
      className: treeTypeButtonClassName,
      type: "button",
      children: showExportDOM ? "Tree" : "Export DOM"
    }) : null, !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2 && (0, import_jsx_runtime.jsx)("button", {
      onClick: () => {
        setEditorReadOnly(true);
        playingIndexRef.current = totalEditorStates - 1;
        setTimeTravelEnabled(true);
      },
      className: timeTravelButtonClassName,
      type: "button",
      children: "Time Travel"
    }), (showLimited || !isLimited) && (0, import_jsx_runtime.jsx)("pre", {
      ref,
      children: content
    }), timeTravelEnabled && (showLimited || !isLimited) && (0, import_jsx_runtime.jsxs)("div", {
      className: timeTravelPanelClassName,
      children: [(0, import_jsx_runtime.jsx)("button", {
        className: timeTravelPanelButtonClassName,
        onClick: () => {
          if (playingIndexRef.current === totalEditorStates - 1) {
            playingIndexRef.current = 1;
          }
          setIsPlaying(!isPlaying);
        },
        type: "button",
        children: isPlaying ? "Pause" : "Play"
      }), (0, import_jsx_runtime.jsx)("input", {
        className: timeTravelPanelSliderClassName,
        ref: inputRef,
        onChange: (event) => {
          const editorStateIndex = Number(event.target.value);
          const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];
          if (timeStampedEditorState) {
            playingIndexRef.current = editorStateIndex;
            setEditorState(timeStampedEditorState[1]);
          }
        },
        type: "range",
        min: "1",
        max: totalEditorStates - 1
      }), (0, import_jsx_runtime.jsx)("button", {
        className: timeTravelPanelButtonClassName,
        onClick: () => {
          setEditorReadOnly(false);
          const index = timeStampedEditorStates.length - 1;
          const timeStampedEditorState = timeStampedEditorStates[index];
          setEditorState(timeStampedEditorState[1]);
          const input = inputRef.current;
          if (input !== null) {
            input.value = String(index);
          }
          setTimeTravelEnabled(false);
          setIsPlaying(false);
        },
        type: "button",
        children: "Exit"
      })]
    })]
  });
});
function registerLexicalCommandLogger(editor, setLoggedCommands) {
  const unregisterCommandListeners = /* @__PURE__ */ new Set();
  let i = 0;
  for (const [command] of editor._commands) {
    unregisterCommandListeners.add(editor.registerCommand(command, (payload) => {
      setLoggedCommands((state) => {
        i += 1;
        const newState = [...state];
        newState.push({
          index: i,
          payload,
          type: command.type ? command.type : "UNKNOWN"
        });
        if (newState.length > 10) {
          newState.shift();
        }
        return newState;
      });
      return false;
    }, COMMAND_PRIORITY_CRITICAL));
  }
  return () => unregisterCommandListeners.forEach((unregister) => unregister());
}
function useLexicalCommandsLog(editor) {
  const [loggedCommands, setLoggedCommands] = (0, import_react.useState)([]);
  (0, import_react.useEffect)(() => {
    return registerLexicalCommandLogger(editor, setLoggedCommands);
  }, [editor]);
  return (0, import_react.useMemo)(() => loggedCommands, [loggedCommands]);
}

// node_modules/@lexical/react/LexicalTreeView.dev.mjs
var React = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function TreeView2({
  treeTypeButtonClassName,
  timeTravelButtonClassName,
  timeTravelPanelSliderClassName,
  timeTravelPanelButtonClassName,
  timeTravelPanelClassName,
  viewClassName,
  editor,
  customPrintNode
}) {
  const treeElementRef = React.createRef();
  const [editorCurrentState, setEditorCurrentState] = (0, import_react2.useState)(editor.getEditorState());
  const commandsLog = useLexicalCommandsLog(editor);
  (0, import_react2.useEffect)(() => {
    return mergeRegister(editor.registerUpdateListener(({
      editorState
    }) => {
      setEditorCurrentState(editorState);
    }), editor.registerEditableListener(() => {
      setEditorCurrentState(editor.getEditorState());
    }));
  }, [editor]);
  (0, import_react2.useEffect)(() => {
    const element = treeElementRef.current;
    if (element !== null) {
      element.__lexicalEditor = editor;
      return () => {
        element.__lexicalEditor = null;
      };
    }
  }, [editor, treeElementRef]);
  const handleEditorReadOnly = (isReadonly) => {
    const rootElement = editor.getRootElement();
    if (rootElement == null) {
      return;
    }
    rootElement.contentEditable = isReadonly ? "false" : "true";
  };
  return (0, import_jsx_runtime2.jsx)(TreeView, {
    treeTypeButtonClassName,
    timeTravelButtonClassName,
    timeTravelPanelSliderClassName,
    timeTravelPanelButtonClassName,
    viewClassName,
    timeTravelPanelClassName,
    setEditorReadOnly: handleEditorReadOnly,
    editorState: editorCurrentState,
    setEditorState: (state) => editor.setEditorState(state),
    generateContent: async function(exportDOM) {
      return generateContent(editor, commandsLog, exportDOM, customPrintNode);
    },
    ref: treeElementRef
  });
}
export {
  TreeView2 as TreeView
};
//# sourceMappingURL=@lexical_react_LexicalTreeView.js.map
