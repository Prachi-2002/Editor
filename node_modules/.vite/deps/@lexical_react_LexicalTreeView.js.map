{
  "version": 3,
  "sources": ["../../@lexical/link/LexicalLink.dev.mjs", "../../@lexical/mark/LexicalMark.dev.mjs", "../../@lexical/table/LexicalTable.dev.mjs", "../../@lexical/devtools-core/LexicalDevtoolsCore.dev.mjs", "../../@lexical/react/LexicalTreeView.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, isHTMLAnchorElement, $findMatchingParent } from '@lexical/utils';\nimport { createCommand, ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $getSelection, $normalizeSelection__EXPERIMENTAL, $setSelection } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url = '', attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    element.href = this.sanitizeUrl(this.__url);\n    if (this.__target !== null) {\n      element.target = this.__target;\n    }\n    if (this.__rel !== null) {\n      element.rel = this.__rel;\n    }\n    if (this.__title !== null) {\n      element.title = this.__title;\n    }\n    addClassNamesToElement(element, config.theme.link);\n    return element;\n  }\n  updateDOM(prevNode, anchor, config) {\n    if (isHTMLAnchorElement(anchor)) {\n      const url = this.__url;\n      const target = this.__target;\n      const rel = this.__rel;\n      const title = this.__title;\n      if (url !== prevNode.__url) {\n        anchor.href = url;\n      }\n      if (target !== prevNode.__target) {\n        if (target) {\n          anchor.target = target;\n        } else {\n          anchor.removeAttribute('target');\n        }\n      }\n      if (rel !== prevNode.__rel) {\n        if (rel) {\n          anchor.rel = rel;\n        } else {\n          anchor.removeAttribute('rel');\n        }\n      }\n      if (title !== prevNode.__title) {\n        if (title) {\n          anchor.title = title;\n        } else {\n          anchor.removeAttribute('title');\n        }\n      }\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);\n  }\n  sanitizeUrl(url) {\n    try {\n      const parsedUrl = new URL(url);\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      url: this.getURL()\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n    return writable;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n    return writable;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n    return writable;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n    return writable;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if (isHTMLAnchorElement(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n\n  constructor(url = '', attributes = {}, key) {\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    return $createAutoLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ($isElementNode(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url = '', attributes) {\n  return $applyNodeReplacement(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = createCommand('TOGGLE_LINK_COMMAND');\nfunction $getPointNode(point, offset) {\n  if (point.type === 'element') {\n    const node = point.getNode();\n    if (!$isElementNode(node)) {\n      throw Error(`$getPointNode: element point is not an ElementNode`);\n    }\n    const childNode = node.getChildren()[point.offset + offset];\n    return childNode || null;\n  }\n  return null;\n}\n\n/**\n * Preserve the logical start/end of a RangeSelection in situations where\n * the point is an element that may be reparented in the callback.\n *\n * @param $fn The function to run\n * @returns The result of the callback\n */\nfunction $withSelectedNodes($fn) {\n  const initialSelection = $getSelection();\n  if (!$isRangeSelection(initialSelection)) {\n    return $fn();\n  }\n  const normalized = $normalizeSelection__EXPERIMENTAL(initialSelection);\n  const isBackwards = normalized.isBackward();\n  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);\n  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);\n  const rval = $fn();\n  if (anchorNode || focusNode) {\n    const updatedSelection = $getSelection();\n    if ($isRangeSelection(updatedSelection)) {\n      const finalSelection = updatedSelection.clone();\n      if (anchorNode) {\n        const anchorParent = anchorNode.getParent();\n        if (anchorParent) {\n          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), 'element');\n        }\n      }\n      if (focusNode) {\n        const focusParent = focusNode.getParent();\n        if (focusParent) {\n          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), 'element');\n        }\n      }\n      $setSelection($normalizeSelection__EXPERIMENTAL(finalSelection));\n    }\n  }\n  return rval;\n}\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return;\n  }\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parentLink = $findMatchingParent(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n      if (parentLink) {\n        const children = parentLink.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parentLink.insertBefore(children[i]);\n        }\n        parentLink.remove();\n      }\n    });\n    return;\n  }\n  const updatedNodes = new Set();\n  const updateLinkNode = linkNode => {\n    if (updatedNodes.has(linkNode.getKey())) {\n      return;\n    }\n    updatedNodes.add(linkNode.getKey());\n    linkNode.setURL(url);\n    if (target !== undefined) {\n      linkNode.setTarget(target);\n    }\n    if (rel !== undefined) {\n      linkNode.setRel(rel);\n    }\n    if (title !== undefined) {\n      linkNode.setTitle(title);\n    }\n  };\n  // Add or merge LinkNodes\n  if (nodes.length === 1) {\n    const firstNode = nodes[0];\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode = $getAncestor(firstNode, $isLinkNode);\n    if (linkNode !== null) {\n      return updateLinkNode(linkNode);\n    }\n  }\n  $withSelectedNodes(() => {\n    let linkNode = null;\n    for (const node of nodes) {\n      if (!node.isAttached()) {\n        continue;\n      }\n      const parentLinkNode = $getAncestor(node, $isLinkNode);\n      if (parentLinkNode) {\n        updateLinkNode(parentLinkNode);\n        continue;\n      }\n      if ($isElementNode(node)) {\n        if (!node.isInline()) {\n          // Ignore block nodes, if there are any children we will see them\n          // later and wrap in a new LinkNode\n          continue;\n        }\n        if ($isLinkNode(node)) {\n          // If it's not an autolink node and we don't already have a LinkNode\n          // in this block then we can update it and re-use it\n          if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {\n            updateLinkNode(node);\n            linkNode = node;\n            continue;\n          }\n          // Unwrap LinkNode, we already have one or it's an AutoLinkNode\n          for (const child of node.getChildren()) {\n            node.insertBefore(child);\n          }\n          node.remove();\n          continue;\n        }\n      }\n      const prevLinkNode = node.getPreviousSibling();\n      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {\n        prevLinkNode.append(node);\n        continue;\n      }\n      linkNode = $createLinkNode(url, {\n        rel,\n        target,\n        title\n      });\n      node.insertAfter(linkNode);\n      linkNode.append(node);\n    }\n  });\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\nexport { $createAutoLinkNode, $createLinkNode, $isAutoLinkNode, $isLinkNode, $toggleLink, AutoLinkNode, LinkNode, TOGGLE_LINK_COMMAND, toggleLink };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { ElementNode, $isRangeSelection, $applyNodeReplacement, $isElementNode, $isTextNode } from 'lexical';\nimport { addClassNamesToElement, removeClassNamesFromElement } from '@lexical/utils';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst NO_IDS = [];\n\n/** @noInheritDoc */\nclass MarkNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'mark';\n  }\n  static clone(node) {\n    return new MarkNode(node.__ids, node.__key);\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedNode) {\n    return $createMarkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIDs(serializedNode.ids);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ids: this.getIDs()\n    };\n  }\n  constructor(ids = NO_IDS, key) {\n    super(key);\n    this.__ids = ids;\n  }\n  createDOM(config) {\n    const element = document.createElement('mark');\n    addClassNamesToElement(element, config.theme.mark);\n    if (this.__ids.length > 1) {\n      addClassNamesToElement(element, config.theme.markOverlap);\n    }\n    return element;\n  }\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          addClassNamesToElement(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        removeClassNamesFromElement(element, overlapTheme);\n      }\n    }\n    return false;\n  }\n  hasID(id) {\n    return this.getIDs().includes(id);\n  }\n  getIDs() {\n    return Array.from(this.getLatest().__ids);\n  }\n  setIDs(ids) {\n    const self = this.getWritable();\n    self.__ids = ids;\n    return self;\n  }\n  addID(id) {\n    const self = this.getWritable();\n    return self.__ids.includes(id) ? self : self.setIDs([...self.__ids, id]);\n  }\n  deleteID(id) {\n    const self = this.getWritable();\n    const idx = self.__ids.indexOf(id);\n    if (idx === -1) {\n      return self;\n    }\n    const ids = Array.from(self.__ids);\n    ids.splice(idx, 1);\n    return self.setIDs(ids);\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const markNode = $createMarkNode(this.__ids);\n    this.insertAfter(markNode, restoreSelection);\n    return markNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection) || destination === 'html') {\n      return false;\n    }\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n}\nfunction $createMarkNode(ids = NO_IDS) {\n  return $applyNodeReplacement(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n    target = child;\n  }\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  const nodes = selection.getNodes();\n  const anchorOffset = selection.anchor.offset;\n  const focusOffset = selection.focus.offset;\n  const nodesLength = nodes.length;\n  const startOffset = isBackward ? focusOffset : anchorOffset;\n  const endOffset = isBackward ? anchorOffset : focusOffset;\n  let currentNodeParent;\n  let lastCreatedMarkNode;\n\n  // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ($isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n    const isFirstNode = i === 0;\n    const isLastNode = i === nodesLength - 1;\n    let targetNode = null;\n    if ($isTextNode(node)) {\n      // Case 1: The node is a text node and we can split it\n      const textContentSize = node.getTextContentSize();\n      const startTextOffset = isFirstNode ? startOffset : 0;\n      const endTextOffset = isLastNode ? endOffset : textContentSize;\n      if (startTextOffset === 0 && endTextOffset === 0) {\n        continue;\n      }\n      const splitNodes = node.splitText(startTextOffset, endTextOffset);\n      targetNode = splitNodes.length > 1 && (splitNodes.length === 3 || isFirstNode && !isLastNode || endTextOffset === textContentSize) ? splitNodes[1] : splitNodes[0];\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may utlimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n\n      continue;\n    } else if ($isElementNode(node) && node.isInline()) {\n      // Case 3: inline element nodes can be added in their entirety to the new\n      // mark\n      targetNode = node;\n    }\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n      const parentNode = targetNode.getParent();\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n      currentNodeParent = parentNode;\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      }\n\n      // Add the target node to be wrapped in the latest created mark node\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n  // Make selection collapsed at the end\n  if ($isElementNode(lastCreatedMarkNode)) {\n    // eslint-disable-next-line no-unused-expressions\n    isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if ($isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\n\nexport { $createMarkNode, $getMarkIDs, $isMarkNode, $unwrapMarkNode, $wrapSelectionInMarkNode, MarkNode };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, $descendantsMatching, $findMatchingParent, removeClassNamesFromElement, objectKlassEquals, isHTMLElement as isHTMLElement$1, $insertFirst as $insertFirst$1, mergeRegister, $insertNodeToNearestRoot, $unwrapAndFilterDescendants } from '@lexical/utils';\nimport { ElementNode, isHTMLElement, $createParagraphNode, $isElementNode, $isLineBreakNode, $isTextNode, $applyNodeReplacement, createCommand, $createTextNode, $getSelection, $isRangeSelection, $createPoint, $isParagraphNode, $normalizeSelection__EXPERIMENTAL, isCurrentlyReadOnlyMode, TEXT_TYPE_TO_FORMAT, $getNodeByKey, $getEditor, $setSelection, SELECTION_CHANGE_COMMAND, getDOMSelection, $createRangeSelection, COMMAND_PRIORITY_HIGH, KEY_ESCAPE_COMMAND, COMMAND_PRIORITY_CRITICAL, CUT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, KEY_TAB_COMMAND, FOCUS_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getPreviousSelection, $getNearestNodeFromDOMNode, $createRangeSelectionFromDom, INSERT_PARAGRAPH_COMMAND, $isRootOrShadowRoot, $isDecoratorNode, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_UP_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, isDOMNode, setDOMUnmanaged, COMMAND_PRIORITY_EDITOR } from 'lexical';\nimport { copyToClipboard, $getClipboardDataFromSelection } from '@lexical/clipboard';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n  afterCloneFrom(node) {\n    super.afterCloneFrom(node);\n    this.__rowSpan = node.__rowSpan;\n    this.__backgroundColor = node.__backgroundColor;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableCellNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeaderStyles(serializedNode.headerState).setColSpan(serializedNode.colSpan || 1).setRowSpan(serializedNode.rowSpan || 1).setWidth(serializedNode.width || undefined).setBackgroundColor(serializedNode.backgroundColor || null);\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const output = super.exportDOM(editor);\n    if (isHTMLElement(output.element)) {\n      const element = output.element;\n      element.setAttribute('data-temporary-table-cell-lexical-key', this.getKey());\n      element.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element.rowSpan = this.__rowSpan;\n      }\n      element.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element.style.verticalAlign = 'top';\n      element.style.textAlign = 'start';\n      if (this.__backgroundColor === null && this.hasHeader()) {\n        element.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return output;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.getLatest().__colSpan;\n  }\n  setColSpan(colSpan) {\n    const self = this.getWritable();\n    self.__colSpan = colSpan;\n    return self;\n  }\n  getRowSpan() {\n    return this.getLatest().__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    const self = this.getWritable();\n    self.__rowSpan = rowSpan;\n    return self;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {\n    const self = this.getWritable();\n    self.__headerState = headerState & mask | self.__headerState & ~mask;\n    return self;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return self;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    const self = this.getWritable();\n    self.__backgroundColor = newBackgroundColor;\n    return self;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const style = domNode_.style;\n  const textDecoration = (style && style.textDecoration || '').split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      if (childLexicalNodes.length === 0) {\n        childLexicalNodes.push($createParagraphNode());\n      }\n      return childLexicalNodes;\n    },\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !$isElementNode(lexicalNode)) {\n        const paragraphNode = $createParagraphNode();\n        if ($isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n        if ($isTextNode(lexicalNode)) {\n          if (hasBoldFontWeight) {\n            lexicalNode.toggleFormat('bold');\n          }\n          if (hasLinethroughTextDecoration) {\n            lexicalNode.toggleFormat('strikethrough');\n          }\n          if (hasItalicFontStyle) {\n            lexicalNode.toggleFormat('italic');\n          }\n          if (hasUnderlineTextDecoration) {\n            lexicalNode.toggleFormat('underline');\n          }\n        }\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width) {\n  return $applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = createCommand('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeight(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    const height = this.getHeight();\n    return {\n      ...super.exportJSON(),\n      ...(height === undefined ? undefined : {\n        height\n      })\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return self;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    after: children => $descendantsMatching(children, $isTableCellNode),\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return $applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = $createParagraphNode();\n      paragraphNode.append($createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append($createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\n\n/**\n * Inserts a table row before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  let insertedRow = null;\n  if (insertAfter) {\n    const insertAfterEndRow = Math.max(focusStartRow + focusCell.__rowSpan, anchorStartRow + anchorCell.__rowSpan) - 1;\n    const insertAfterEndRowMap = gridMap[insertAfterEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertAfterEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= insertAfterEndRow) {\n        const currentCell = insertAfterEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertAfterEndRowNode = grid.getChildAtIndex(insertAfterEndRow);\n    if (!$isTableRowNode(insertAfterEndRowNode)) {\n      throw Error(`insertAfterEndRow is not a TableRowNode`);\n    }\n    insertAfterEndRowNode.insertAfter(newRow);\n    insertedRow = newRow;\n  } else {\n    const insertBeforeStartRow = Math.min(focusStartRow, anchorStartRow);\n    const insertBeforeStartRowMap = gridMap[insertBeforeStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertBeforeStartRowMap[i];\n      if (startRow === insertBeforeStartRow) {\n        const currentCell = insertBeforeStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertBeforeStartRowNode = grid.getChildAtIndex(insertBeforeStartRow);\n    if (!$isTableRowNode(insertBeforeStartRowNode)) {\n      throw Error(`insertBeforeStartRow is not a TableRowNode`);\n    }\n    insertBeforeStartRowNode.insertBefore(newRow);\n    insertedRow = newRow;\n  }\n  return insertedRow;\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append($createParagraphNode());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\n\n/**\n * Inserts a column before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append($createParagraphNode());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;\n    const newWidth = newColWidths[columnIndex];\n    newColWidths.splice(columnIndex, 0, newWidth);\n    grid.setColWidths(newColWidths);\n  }\n  return firstInsertedCell;\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const selectedRowCount = anchorCell.__rowSpan;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top have to be trimmed\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        const overflowTop = anchorStartRow - cellStartRow;\n        cell.setRowSpan(cell.__rowSpan - Math.min(selectedRowCount, cell.__rowSpan - overflowTop));\n      }\n      // Rows overflowing bottom have to be trimmed and moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n        let insertAfterCell = null;\n        for (let columnIndex = 0; columnIndex < column; columnIndex++) {\n          const currentCellMap = nextRow[columnIndex];\n          const currentCell = currentCellMap.cell;\n          // Checking the cell having startRow as same as nextRow\n          if (currentCellMap.startRow === row + 1) {\n            insertAfterCell = currentCell;\n          }\n          if (currentCell.__colSpan > 1) {\n            columnIndex += currentCell.__colSpan - 1;\n          }\n        }\n        if (insertAfterCell === null) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          insertAfterCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    newColWidths.splice(startColumn, selectedColumnCount);\n    grid.setColWidths(newColWidths);\n  }\n}\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $unmergeCell() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = $getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan === 1 && rowSpan === 1) {\n    return;\n  }\n  const [map, cellMap] = $computeTableMap(grid, cell, cell);\n  const {\n    startColumn,\n    startRow\n  } = cellMap;\n  // Create a heuristic for what the style of the unmerged cells should be\n  // based on whether every row or column already had that state before the\n  // unmerge.\n  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;\n  const colStyles = Array.from({\n    length: colSpan\n  }, (_v, i) => {\n    let colStyle = baseColStyle;\n    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {\n      colStyle &= map[rowIdx][i + startColumn].cell.__headerState;\n    }\n    return colStyle;\n  });\n  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;\n  const rowStyles = Array.from({\n    length: rowSpan\n  }, (_v, i) => {\n    let rowStyle = baseRowStyle;\n    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {\n      rowStyle &= map[i + startRow][colIdx].cell.__headerState;\n    }\n    return rowStyle;\n  });\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(colStyles[i] | rowStyles[0]).append($createParagraphNode()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          $insertFirst(currentRowNode, $createTableCellNode(colStyles[j] | rowStyles[i]).append($createParagraphNode()));\n        }\n      } else {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          insertAfterCell.insertAfter($createTableCellNode(colStyles[j] | rowStyles[i]).append($createParagraphNode()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(tableNode, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(tableNode, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Table`);\n  }\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Table`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(tableNode, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function getMapRow(i) {\n    let row = tableMap[i];\n    if (row === undefined) {\n      tableMap[i] = row = [];\n    }\n    return row;\n  }\n  const gridChildren = tableNode.getChildren();\n  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {\n    const row = gridChildren[rowIdx];\n    if (!$isTableRowNode(row)) {\n      throw Error(`Expected TableNode children to be TableRowNode`);\n    }\n    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {\n      if (!$isTableCellNode(cell)) {\n        throw Error(`Expected TableRowNode children to be TableCellNode`);\n      } // Skip past any columns that were merged from a higher row\n      const startMapRow = getMapRow(rowIdx);\n      while (startMapRow[colIdx] !== undefined) {\n        colIdx++;\n      }\n      const value = {\n        cell,\n        startColumn: colIdx,\n        startRow: rowIdx\n      };\n      const {\n        __rowSpan: rowSpan,\n        __colSpan: colSpan\n      } = cell;\n      for (let j = 0; j < rowSpan; j++) {\n        if (rowIdx + j >= gridChildren.length) {\n          // The table is non-rectangular with a rowSpan\n          // below the last <tr> in the table.\n          // We should probably handle this with a node transform\n          // to ensure that tables are always rectangular but this\n          // will avoid crashes such as #6584\n          // Note that there are probably still latent bugs\n          // regarding colSpan or general cell count mismatches.\n          break;\n        }\n        const mapRow = getMapRow(rowIdx + j);\n        for (let i = 0; i < colSpan; i++) {\n          mapRow[colIdx + i] = value;\n        }\n      }\n      if (cellA !== null && cellAValue === null && cellA.is(cell)) {\n        cellAValue = value;\n      }\n      if (cellB !== null && cellBValue === null && cellB.is(cell)) {\n        cellBValue = value;\n      }\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = $findMatchingParent(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    throw Error(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    throw Error(`Expected TableRowNode to have a parent TableNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $computeTableCellRectSpans(map, boundary) {\n  const {\n    minColumn,\n    maxColumn,\n    minRow,\n    maxRow\n  } = boundary;\n  let topSpan = 1;\n  let leftSpan = 1;\n  let rightSpan = 1;\n  let bottomSpan = 1;\n  const topRow = map[minRow];\n  const bottomRow = map[maxRow];\n  for (let col = minColumn; col <= maxColumn; col++) {\n    topSpan = Math.max(topSpan, topRow[col].cell.__rowSpan);\n    bottomSpan = Math.max(bottomSpan, bottomRow[col].cell.__rowSpan);\n  }\n  for (let row = minRow; row <= maxRow; row++) {\n    leftSpan = Math.max(leftSpan, map[row][minColumn].cell.__colSpan);\n    rightSpan = Math.max(rightSpan, map[row][maxColumn].cell.__colSpan);\n  }\n  return {\n    bottomSpan,\n    leftSpan,\n    rightSpan,\n    topSpan\n  };\n}\nfunction $computeTableCellRectBoundary(map, cellAMap, cellBMap) {\n  let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n  let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n  let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n  let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n  let exploredMinColumn = minColumn;\n  let exploredMinRow = minRow;\n  let exploredMaxColumn = minColumn;\n  let exploredMaxRow = minRow;\n  function expandBoundary(mapValue) {\n    const {\n      cell,\n      startColumn: cellStartColumn,\n      startRow: cellStartRow\n    } = mapValue;\n    minColumn = Math.min(minColumn, cellStartColumn);\n    minRow = Math.min(minRow, cellStartRow);\n    maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n    maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n  }\n  while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n    if (minColumn < exploredMinColumn) {\n      // Expand on the left\n      const rowDiff = exploredMaxRow - exploredMinRow;\n      const previousColumn = exploredMinColumn - 1;\n      for (let i = 0; i <= rowDiff; i++) {\n        expandBoundary(map[exploredMinRow + i][previousColumn]);\n      }\n      exploredMinColumn = previousColumn;\n    }\n    if (minRow < exploredMinRow) {\n      // Expand on top\n      const columnDiff = exploredMaxColumn - exploredMinColumn;\n      const previousRow = exploredMinRow - 1;\n      for (let i = 0; i <= columnDiff; i++) {\n        expandBoundary(map[previousRow][exploredMinColumn + i]);\n      }\n      exploredMinRow = previousRow;\n    }\n    if (maxColumn > exploredMaxColumn) {\n      // Expand on the right\n      const rowDiff = exploredMaxRow - exploredMinRow;\n      const nextColumn = exploredMaxColumn + 1;\n      for (let i = 0; i <= rowDiff; i++) {\n        expandBoundary(map[exploredMinRow + i][nextColumn]);\n      }\n      exploredMaxColumn = nextColumn;\n    }\n    if (maxRow > exploredMaxRow) {\n      // Expand on the bottom\n      const columnDiff = exploredMaxColumn - exploredMinColumn;\n      const nextRow = exploredMaxRow + 1;\n      for (let i = 0; i <= columnDiff; i++) {\n        expandBoundary(map[nextRow][exploredMinColumn + i]);\n      }\n      exploredMaxRow = nextRow;\n    }\n  }\n  return {\n    maxColumn,\n    maxRow,\n    minColumn,\n    minRow\n  };\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $getCellNodes(tableSelection) {\n  const [[anchorNode, anchorCell, anchorRow, anchorTable], [focusNode, focusCell, focusRow, focusTable]] = ['anchor', 'focus'].map(k => {\n    const node = tableSelection[k].getNode();\n    const cellNode = $findMatchingParent(node, $isTableCellNode);\n    if (!$isTableCellNode(cellNode)) {\n      throw Error(`Expected TableSelection ${k} to be (or a child of) TableCellNode, got key ${node.getKey()} of type ${node.getType()}`);\n    }\n    const rowNode = cellNode.getParent();\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected TableSelection ${k} cell parent to be a TableRowNode`);\n    }\n    const tableNode = rowNode.getParent();\n    if (!$isTableNode(tableNode)) {\n      throw Error(`Expected TableSelection ${k} row parent to be a TableNode`);\n    }\n    return [node, cellNode, rowNode, tableNode];\n  });\n  // TODO: nested tables may violate this\n  if (!anchorTable.is(focusTable)) {\n    throw Error(`Expected TableSelection anchor and focus to be in the same table`);\n  }\n  return {\n    anchorCell,\n    anchorNode,\n    anchorRow,\n    anchorTable,\n    focusCell,\n    focusNode,\n    focusRow,\n    focusTable\n  };\n}\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * {@link $createTableSelection} unfortunately makes it very easy to create\n   * nonsense selections, so we have a method to see if the selection probably\n   * makes sense.\n   *\n   * @returns true if the TableSelection is (probably) valid\n   */\n  isValid() {\n    return this.tableKey !== 'root' && this.anchor.key !== 'root' && this.anchor.type === 'element' && this.focus.key !== 'root' && this.focus.type === 'element';\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    return $isTableSelection(selection) && this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    // note: closure compiler's acorn does not support ||=\n    this.dirty = this.dirty || tableKey !== this.tableKey || anchorCellKey !== this.anchor.key || focusCellKey !== this.focus.key;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, $createPoint(this.anchor.key, this.anchor.offset, this.anchor.type), $createPoint(this.focus.key, this.focus.offset, this.focus.type));\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection.\n   * This will be true if any paragraph in table cells has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    let format = 0;\n    const cellNodes = this.getNodes().filter($isTableCellNode);\n    cellNodes.forEach(cellNode => {\n      const paragraph = cellNode.getFirstChild();\n      if ($isParagraphNode(paragraph)) {\n        format |= paragraph.getTextFormat();\n      }\n    });\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (format & formatFlag) !== 0;\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!$isElementNode(focusNode)) {\n      throw Error(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = $normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const {\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCell);\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCell);\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    if (!this.isValid()) {\n      return [];\n    }\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const {\n      anchorTable: tableNode,\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          throw Error(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          throw Error(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    const {\n      minColumn,\n      maxColumn,\n      minRow,\n      maxRow\n    } = $computeTableCellRectBoundary(map, cellAMap, cellBMap);\n\n    // We use a Map here because merged cells in the grid would otherwise\n    // show up multiple times in the nodes array\n    const nodeMap = new Map([[tableNode.getKey(), tableNode]]);\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          throw Error(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodeMap.set(currentRow.getKey(), currentRow);\n          lastRow = currentRow;\n        }\n        if (!nodeMap.has(cell.getKey())) {\n          $visitRecursively(cell, childNode => {\n            nodeMap.set(childNode.getKey(), childNode);\n          });\n        }\n      }\n    }\n    const nodes = Array.from(nodeMap.values());\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  // TODO this is a suboptimal design, it doesn't make sense to have\n  // a table selection that isn't associated with a table. This\n  // constructor should have required argumnets and in true we\n  // should check that they point to a table and are element points to\n  // cell nodes of that table.\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $createTableSelectionFrom(tableNode, anchorCell, focusCell) {\n  const tableNodeKey = tableNode.getKey();\n  const anchorCellKey = anchorCell.getKey();\n  const focusCellKey = focusCell.getKey();\n  {\n    if (!tableNode.isAttached()) {\n      throw Error(`$createTableSelectionFrom: tableNode ${tableNodeKey} is not attached`);\n    }\n    if (!tableNode.is($findTableNode(anchorCell))) {\n      throw Error(`$createTableSelectionFrom: anchorCell ${anchorCellKey} is not in table ${tableNodeKey}`);\n    }\n    if (!tableNode.is($findTableNode(focusCell))) {\n      throw Error(`$createTableSelectionFrom: focusCell ${focusCellKey} is not in table ${tableNodeKey}`);\n    } // TODO: Check for rectangular grid\n  }\n  const prevSelection = $getSelection();\n  const nextSelection = $isTableSelection(prevSelection) ? prevSelection.clone() : $createTableSelection();\n  nextSelection.set(tableNode.getKey(), anchorCell.getKey(), focusCell.getKey());\n  return nextSelection;\n}\n\n/**\n * Depth first visitor\n * @param node The starting node\n * @param $visit The function to call for each node. If the function returns false, then children of this node will not be explored\n */\nfunction $visitRecursively(node, $visit) {\n  const stack = [[node]];\n  for (let currentArray = stack.at(-1); currentArray !== undefined && stack.length > 0; currentArray = stack.at(-1)) {\n    const currentNode = currentArray.pop();\n    if (currentNode === undefined) {\n      stack.pop();\n    } else if ($visit(currentNode) !== false && $isElementNode(currentNode)) {\n      stack.push(currentNode.getChildren());\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $getTableAndElementByKey(tableNodeKey, editor = $getEditor()) {\n  const tableNode = $getNodeByKey(tableNodeKey);\n  if (!$isTableNode(tableNode)) {\n    throw Error(`TableObserver: Expected tableNodeKey ${tableNodeKey} to be a TableNode`);\n  }\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNodeKey));\n  if (!(tableElement !== null)) {\n    throw Error(`TableObserver: Expected to find TableElement in DOM for key ${tableNodeKey}`);\n  }\n  return {\n    tableElement,\n    tableNode\n  };\n}\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.isSelecting = false;\n    this.shouldCheckSelection = false;\n    this.abortController = new AbortController();\n    this.listenerOptions = {\n      signal: this.abortController.signal\n    };\n    this.nextFocus = null;\n    this.trackTable();\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    this.abortController.abort('removeListeners');\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n    this.listenersToRemove.clear();\n  }\n  $lookup() {\n    return $getTableAndElementByKey(this.tableNodeKey, this.editor);\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.getEditorState().read(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const {\n          tableNode,\n          tableElement\n        } = this.$lookup();\n        this.table = getTable(tableNode, tableElement);\n      }, {\n        editor: this.editor\n      });\n    });\n    this.editor.getEditorState().read(() => {\n      const {\n        tableNode,\n        tableElement\n      } = this.$lookup();\n      this.table = getTable(tableNode, tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }, {\n      editor: this.editor\n    });\n  }\n  $clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.$enableHighlightStyle();\n    const {\n      tableNode,\n      tableElement\n    } = this.$lookup();\n    const grid = getTable(tableNode, tableElement);\n    $updateDOMForSelection(editor, grid, null);\n    if ($getSelection() !== null) {\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    }\n  }\n  $enableHighlightStyle() {\n    const editor = this.editor;\n    const {\n      tableElement\n    } = this.$lookup();\n    removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n    tableElement.classList.remove('disable-selection');\n    this.hasHijackedSelectionStyles = false;\n  }\n  $disableHighlightStyle() {\n    const {\n      tableElement\n    } = this.$lookup();\n    addClassNamesToElement(tableElement, this.editor._config.theme.tableSelection);\n    this.hasHijackedSelectionStyles = true;\n  }\n  $updateTableTableSelection(selection) {\n    if (selection !== null) {\n      if (!(selection.tableKey === this.tableNodeKey)) {\n        throw Error(`TableObserver.$updateTableTableSelection: selection.tableKey !== this.tableNodeKey ('${selection.tableKey}' !== '${this.tableNodeKey}')`);\n      }\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n      this.updateDOMSelection();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else {\n      this.$clearHighlight();\n    }\n  }\n\n  /**\n   * @internal\n   * Firefox has a strange behavior where pressing the down arrow key from\n   * above the table will move the caret after the table and then lexical\n   * will select the last cell instead of the first.\n   * We do still want to let the browser handle caret movement but we will\n   * use this property to \"tag\" the update so that we can recheck the\n   * selection after the event is processed.\n   */\n  setShouldCheckSelection() {\n    this.shouldCheckSelection = true;\n  }\n  /**\n   * @internal\n   */\n  getAndClearShouldCheckSelection() {\n    if (this.shouldCheckSelection) {\n      this.shouldCheckSelection = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @internal\n   * When handling mousemove events we track what the focus cell should be, but\n   * the DOM selection may end up somewhere else entirely. We don't have an elegant\n   * way to handle this after the DOM selection has been resolved in a\n   * SELECTION_CHANGE_COMMAND callback.\n   */\n  setNextFocus(nextFocus) {\n    this.nextFocus = nextFocus;\n  }\n\n  /** @internal */\n  getAndClearNextFocus() {\n    const {\n      nextFocus\n    } = this;\n    if (nextFocus !== null) {\n      this.nextFocus = null;\n    }\n    return nextFocus;\n  }\n\n  /** @internal */\n  updateDOMSelection() {\n    if (this.anchorCell !== null && this.focusCell !== null) {\n      const domSelection = getDOMSelection(this.editor._window);\n      // We are not using a native selection for tables, and if we\n      // set one then the reconciler will undo it.\n      // TODO - it would make sense to have one so that native\n      //        copy/paste worked. Right now we have to emulate with\n      //        keyboard events but it won't fire if trigged from the menu\n      if (domSelection && domSelection.rangeCount > 0) {\n        domSelection.removeAllRanges();\n      }\n    }\n  }\n  $setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    const {\n      tableNode\n    } = this.$lookup();\n    const cellX = cell.x;\n    const cellY = cell.y;\n    this.focusCell = cell;\n    if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n    } else if (cellX === this.focusX && cellY === this.focusY) {\n      return false;\n    }\n    this.focusX = cellX;\n    this.focusY = cellY;\n    if (this.isHighlightingCells) {\n      const focusTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n      if (this.tableSelection != null && this.anchorCellNodeKey != null && focusTableCellNode !== null) {\n        this.focusCellNodeKey = focusTableCellNode.getKey();\n        this.tableSelection = $createTableSelectionFrom(tableNode, this.$getAnchorTableCellOrThrow(), focusTableCellNode);\n        $setSelection(this.tableSelection);\n        editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        $updateDOMForSelection(editor, this.table, this.tableSelection);\n        return true;\n      }\n    }\n    return false;\n  }\n  $getAnchorTableCell() {\n    return this.anchorCellNodeKey ? $getNodeByKey(this.anchorCellNodeKey) : null;\n  }\n  $getAnchorTableCellOrThrow() {\n    const anchorTableCell = this.$getAnchorTableCell();\n    if (!(anchorTableCell !== null)) {\n      throw Error(`TableObserver anchorTableCell is null`);\n    }\n    return anchorTableCell;\n  }\n  $getFocusTableCell() {\n    return this.focusCellNodeKey ? $getNodeByKey(this.focusCellNodeKey) : null;\n  }\n  $getFocusTableCellOrThrow() {\n    const focusTableCell = this.$getFocusTableCell();\n    if (!(focusTableCell !== null)) {\n      throw Error(`TableObserver focusTableCell is null`);\n    }\n    return focusTableCell;\n  }\n  $setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    const {\n      tableNode\n    } = this.$lookup();\n    const anchorTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n    if (anchorTableCellNode !== null) {\n      const anchorNodeKey = anchorTableCellNode.getKey();\n      this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n      this.anchorCellNodeKey = anchorNodeKey;\n    }\n  }\n  $formatCells(type) {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection)) {\n      throw Error(`Expected Table selection`);\n    }\n    const formatSelection = $createRangeSelection();\n    const anchor = formatSelection.anchor;\n    const focus = formatSelection.focus;\n    const cellNodes = selection.getNodes().filter($isTableCellNode);\n    if (!(cellNodes.length > 0)) {\n      throw Error(`No table cells present`);\n    }\n    const paragraph = cellNodes[0].getFirstChild();\n    const alignFormatWith = $isParagraphNode(paragraph) ? paragraph.getFormatFlags(type, null) : null;\n    cellNodes.forEach(cellNode => {\n      anchor.set(cellNode.getKey(), 0, 'element');\n      focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n      formatSelection.formatText(type, alignFormatWith);\n    });\n    $setSelection(selection);\n    this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  $clearText() {\n    const {\n      editor\n    } = this;\n    const tableNode = $getNodeByKey(this.tableNodeKey);\n    if (!$isTableNode(tableNode)) {\n      throw new Error('Expected TableNode.');\n    }\n    const selection = $getSelection();\n    if (!$isTableSelection(selection)) {\n      throw Error(`Expected TableSelection`);\n    }\n    const selectedNodes = selection.getNodes().filter($isTableCellNode);\n    if (selectedNodes.length === this.table.columns * this.table.rows) {\n      tableNode.selectPrevious();\n      // Delete entire table\n      tableNode.remove();\n      return;\n    }\n    selectedNodes.forEach(cellNode => {\n      if ($isElementNode(cellNode)) {\n        const paragraphNode = $createParagraphNode();\n        const textNode = $createTextNode();\n        paragraphNode.append(textNode);\n        cellNode.append(paragraphNode);\n        cellNode.getChildren().forEach(child => {\n          if (child !== paragraphNode) {\n            child.remove();\n          }\n        });\n      }\n    });\n    $updateDOMForSelection(editor, this.table, null);\n    $setSelection(null);\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst isMouseDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction getTableElement(tableNode, dom) {\n  if (!dom) {\n    return dom;\n  }\n  const element = dom.nodeName === 'TABLE' ? dom : tableNode.getDOMSlot(dom).element;\n  if (!(element.nodeName === 'TABLE')) {\n    throw Error(`getTableElement: Expecting table in as DOM node for TableNode, not ${dom.nodeName}`);\n  }\n  return element;\n}\nfunction getEditorWindow(editor) {\n  return editor._window;\n}\nfunction $findParentTableCellNodeInTable(tableNode, node) {\n  for (let currentNode = node, lastTableCellNode = null; currentNode !== null; currentNode = currentNode.getParent()) {\n    if (tableNode.is(currentNode)) {\n      return lastTableCellNode;\n    } else if ($isTableCellNode(currentNode)) {\n      lastTableCellNode = currentNode;\n    }\n  }\n  return null;\n}\nconst ARROW_KEY_COMMANDS_WITH_DIRECTION = [[KEY_ARROW_DOWN_COMMAND, 'down'], [KEY_ARROW_UP_COMMAND, 'up'], [KEY_ARROW_LEFT_COMMAND, 'backward'], [KEY_ARROW_RIGHT_COMMAND, 'forward']];\nconst DELETE_TEXT_COMMANDS = [DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND];\nconst DELETE_KEY_COMMANDS = [KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND];\nfunction applyTableHandlers(tableNode, element, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  const editorWindow = getEditorWindow(editor);\n  if (!(rootElement !== null && editorWindow !== null)) {\n    throw Error(`applyTableHandlers: editor has no root element set`);\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const tableElement = getTableElement(tableNode, element);\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  tableObserver.listenersToRemove.add(() => detatchTableObserverFromTableElement(tableElement, tableObserver));\n  const createMouseHandlers = () => {\n    if (tableObserver.isSelecting) {\n      return;\n    }\n    const onMouseUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('mouseup', onMouseUp);\n      editorWindow.removeEventListener('mousemove', onMouseMove);\n    };\n    const onMouseMove = moveEvent => {\n      if (!isDOMNode(moveEvent.target)) {\n        return;\n      }\n      if (!isMouseDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n        tableObserver.isSelecting = false;\n        editorWindow.removeEventListener('mouseup', onMouseUp);\n        editorWindow.removeEventListener('mousemove', onMouseMove);\n        return;\n      }\n      const override = !tableElement.contains(moveEvent.target);\n      let focusCell = null;\n      if (!override) {\n        focusCell = getDOMCellFromTarget(moveEvent.target);\n      } else {\n        for (const el of document.elementsFromPoint(moveEvent.clientX, moveEvent.clientY)) {\n          focusCell = tableElement.contains(el) ? getDOMCellFromTarget(el) : null;\n          if (focusCell) {\n            break;\n          }\n        }\n      }\n      if (focusCell && (tableObserver.focusCell === null || focusCell.elem !== tableObserver.focusCell.elem)) {\n        tableObserver.setNextFocus({\n          focusCell,\n          override\n        });\n        editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n      }\n    };\n    tableObserver.isSelecting = true;\n    editorWindow.addEventListener('mouseup', onMouseUp, tableObserver.listenerOptions);\n    editorWindow.addEventListener('mousemove', onMouseMove, tableObserver.listenerOptions);\n  };\n  const onMouseDown = event => {\n    if (event.button !== 0 || !isDOMNode(event.target) || !editorWindow) {\n      return;\n    }\n    const targetCell = getDOMCellFromTarget(event.target);\n    if (targetCell !== null) {\n      editor.update(() => {\n        const prevSelection = $getPreviousSelection();\n        // We can't trust Firefox to do the right thing with the selection and\n        // we don't have a proper state machine to do this \"correctly\" but\n        // if we go ahead and make the table selection now it will work\n        if (IS_FIREFOX && event.shiftKey && $isSelectionInTable(prevSelection, tableNode) && ($isRangeSelection(prevSelection) || $isTableSelection(prevSelection))) {\n          const prevAnchorNode = prevSelection.anchor.getNode();\n          const prevAnchorCell = $findParentTableCellNodeInTable(tableNode, prevSelection.anchor.getNode());\n          if (prevAnchorCell) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCell));\n            tableObserver.$setFocusCellForSelection(targetCell);\n            stopEvent(event);\n          } else {\n            const newSelection = tableNode.isBefore(prevAnchorNode) ? tableNode.selectStart() : tableNode.selectEnd();\n            newSelection.anchor.set(prevSelection.anchor.key, prevSelection.anchor.offset, prevSelection.anchor.type);\n          }\n        } else {\n          tableObserver.$setAnchorCellForSelection(targetCell);\n        }\n      });\n    }\n    createMouseHandlers();\n  };\n  tableElement.addEventListener('mousedown', onMouseDown, tableObserver.listenerOptions);\n\n  // Clear selection when clicking outside of dom.\n  const mouseDownCallback = event => {\n    const target = event.target;\n    if (event.button !== 0 || !isDOMNode(target)) {\n      return;\n    }\n    editor.update(() => {\n      const selection = $getSelection();\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.$clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('mousedown', mouseDownCallback, tableObserver.listenerOptions);\n  for (const [command, direction] of ARROW_KEY_COMMANDS_WITH_DIRECTION) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, event => $handleArrowKey(editor, event, direction, tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ESCAPE_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findParentTableCellNodeInTable(tableNode, selection.focus.getNode());\n      if (focusCellNode !== null) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findParentTableCellNodeInTable(tableNode, selection.anchor.getNode());\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.$clearText();\n        return true;\n      }\n      const nearestElementNode = $findMatchingParent(selection.anchor.getNode(), n => $isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && $findMatchingParent(nearestElementNode, n => $isElementNode(n) && $isTableCellNode(n.getParent()));\n      if (!$isElementNode(topLevelCellElementNode) || !$isElementNode(nearestElementNode)) {\n        return false;\n      }\n      if (command === DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  for (const command of DELETE_TEXT_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), COMMAND_PRIORITY_CRITICAL));\n  }\n  const $deleteCellHandler = event => {\n    const selection = $getSelection();\n    if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n      return false;\n    }\n\n    // If the selection is inside the table but should remove the whole table\n    // we expand the selection so that both the anchor and focus are outside\n    // the table and the editor's command listener will handle the delete\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    if (isAnchorInside !== isFocusInside) {\n      const tablePoint = isAnchorInside ? 'anchor' : 'focus';\n      const outerPoint = isAnchorInside ? 'focus' : 'anchor';\n      // Preserve the outer point\n      const {\n        key,\n        offset,\n        type\n      } = selection[outerPoint];\n      // Expand the selection around the table\n      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? 'selectPrevious' : 'selectNext']();\n      // Restore the outer point of the selection\n      newSelection[outerPoint].set(key, offset, type);\n      // Let the base implementation handle the rest\n      return false;\n    }\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.$clearText();\n      return true;\n    }\n    return false;\n  };\n  for (const command of DELETE_KEY_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, $deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(CUT_COMMAND, event => {\n    const selection = $getSelection();\n    if (selection) {\n      if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null, $getClipboardDataFromSelection(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ($isRangeSelection(selection)) {\n        selection.removeText();\n        return true;\n      }\n      return intercepted;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_TEXT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$formatCells(payload);\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow + anchorCell.cell.__rowSpan - 1, focusCell.startRow + focusCell.cell.__rowSpan - 1);\n    const maxColumn = Math.max(anchorCell.startColumn + anchorCell.cell.__colSpan - 1, focusCell.startColumn + focusCell.cell.__colSpan - 1);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    const visited = new Set();\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        if (visited.has(cell)) {\n          continue;\n        }\n        visited.add(cell);\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ($isElementNode(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearHighlight();\n      return false;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [$createTextNode(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(KEY_TAB_COMMAND, event => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null || !tableNode.is($findTableNode(tableCellNode))) {\n        return false;\n      }\n      stopEvent(event);\n      $selectAdjacentCell(tableCellNode, event.shiftKey ? 'previous' : 'next');\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, selectionPayload => {\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = $isRangeSelection(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && $findMatchingParent(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor] = anchorAndFocus;\n    const newGrid = nodes[0];\n    const newGridRows = newGrid.getChildren();\n    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n    const newRowCount = newGrid.getChildrenSize();\n    const gridCellNode = $findMatchingParent(anchor.getNode(), n => $isTableCellNode(n));\n    const gridRowNode = gridCellNode && $findMatchingParent(gridCellNode, n => $isTableRowNode(n));\n    const gridNode = gridRowNode && $findMatchingParent(gridRowNode, n => $isTableNode(n));\n    if (!$isTableCellNode(gridCellNode) || !$isTableRowNode(gridRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const startY = gridRowNode.getIndexWithinParent();\n    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n    const startX = gridCellNode.getIndexWithinParent();\n    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n    const fromX = Math.min(startX, stopX);\n    const fromY = Math.min(startY, stopY);\n    const toX = Math.max(startX, stopX);\n    const toY = Math.max(startY, stopY);\n    const gridRowNodes = gridNode.getChildren();\n    let newRowIdx = 0;\n    for (let r = fromY; r <= toY; r++) {\n      const currentGridRowNode = gridRowNodes[r];\n      if (!$isTableRowNode(currentGridRowNode)) {\n        return false;\n      }\n      const newGridRowNode = newGridRows[newRowIdx];\n      if (!$isTableRowNode(newGridRowNode)) {\n        return false;\n      }\n      const gridCellNodes = currentGridRowNode.getChildren();\n      const newGridCellNodes = newGridRowNode.getChildren();\n      let newColumnIdx = 0;\n      for (let c = fromX; c <= toX; c++) {\n        const currentGridCellNode = gridCellNodes[c];\n        if (!$isTableCellNode(currentGridCellNode)) {\n          return false;\n        }\n        const newGridCellNode = newGridCellNodes[newColumnIdx];\n        if (!$isTableCellNode(newGridCellNode)) {\n          return false;\n        }\n        const originalChildren = currentGridCellNode.getChildren();\n        newGridCellNode.getChildren().forEach(child => {\n          if ($isTextNode(child)) {\n            const paragraphNode = $createParagraphNode();\n            paragraphNode.append(child);\n            currentGridCellNode.append(child);\n          } else {\n            currentGridCellNode.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n        newColumnIdx++;\n      }\n      newRowIdx++;\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_CHANGE_COMMAND, () => {\n    const selection = $getSelection();\n    const prevSelection = $getPreviousSelection();\n    const nextFocus = tableObserver.getAndClearNextFocus();\n    if (nextFocus !== null) {\n      const {\n        focusCell\n      } = nextFocus;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        if (focusCell.x === tableObserver.focusX && focusCell.y === tableObserver.focusY) {\n          // The selection is already the correct table selection\n          return false;\n        } else {\n          tableObserver.$setFocusCellForSelection(focusCell);\n          return true;\n        }\n      } else if (focusCell !== tableObserver.anchorCell && $isSelectionInTable(selection, tableNode)) {\n        // The selection has crossed cells\n        tableObserver.$setFocusCellForSelection(focusCell);\n        return true;\n      }\n    }\n    const shouldCheckSelection = tableObserver.getAndClearShouldCheckSelection();\n    // If they pressed the down arrow with the selection outside of the\n    // table, and then the selection ends up in the table but not in the\n    // first cell, then move the selection to the first cell.\n    if (shouldCheckSelection && $isRangeSelection(prevSelection) && $isRangeSelection(selection) && selection.isCollapsed()) {\n      const anchor = selection.anchor.getNode();\n      const firstRow = tableNode.getFirstChild();\n      const anchorCell = $findCellNode(anchor);\n      if (anchorCell !== null && $isTableRowNode(firstRow)) {\n        const firstCell = firstRow.getFirstChild();\n        if ($isTableCellNode(firstCell) && tableNode.is($findMatchingParent(anchorCell, node => node.is(tableNode) || node.is(firstCell)))) {\n          // The selection moved to the table, but not in the first cell\n          firstCell.selectStart();\n          return true;\n        }\n      }\n    }\n    if ($isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartiallyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartiallyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        } else if (isAnchorInside) {\n          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          /**\n           * If isBackward, set the anchor to be at the end of the table so that when the cursor moves outside of\n           * the table in the backward direction, the entire table will be selected from its end.\n           * Otherwise, if forward, set the anchor to be at the start of the table so that when the focus is dragged\n           * outside th end of the table, it will start from the beginning of the table.\n           */\n          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, 'element');\n        }\n        $setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into table selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, anchorCellNode));\n          tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = getDOMSelection(editorWindow);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = $getNearestNodeFromDOMNode(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.isParentOf(focusNode);\n        const anchorNode = $getNearestNodeFromDOMNode(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.isParentOf(anchorNode);\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = $createRangeSelectionFromDom(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction detatchTableObserverFromTableElement(tableElement, tableObserver) {\n  if (getTableObserverFromTableElement(tableElement) === tableObserver) {\n    delete tableElement[LEXICAL_ELEMENT_KEY];\n  }\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  if (!(getTableObserverFromTableElement(tableElement) === null)) {\n    throw Error(`tableElement already has an attached TableObserver`);\n  }\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY] || null;\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getTable(tableNode, dom) {\n  const tableElement = getTableElement(tableNode, dom);\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.querySelector('tr');\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = $getNearestNodeFromDOMNode(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.$disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.$enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nfunction $selectAdjacentCell(tableCellNode, direction) {\n  const siblingMethod = direction === 'next' ? 'getNextSibling' : 'getPreviousSibling';\n  const childMethod = direction === 'next' ? 'getFirstChild' : 'getLastChild';\n  const sibling = tableCellNode[siblingMethod]();\n  if ($isElementNode(sibling)) {\n    return sibling.selectEnd();\n  }\n  const parentRow = $findMatchingParent(tableCellNode, $isTableRowNode);\n  if (!(parentRow !== null)) {\n    throw Error(`selectAdjacentCell: Cell not in table row`);\n  }\n  for (let nextRow = parentRow[siblingMethod](); $isTableRowNode(nextRow); nextRow = nextRow[siblingMethod]()) {\n    const child = nextRow[childMethod]();\n    if ($isElementNode(child)) {\n      return child.selectEnd();\n    }\n  }\n  const parentTable = $findMatchingParent(parentRow, $isTableNode);\n  if (!(parentTable !== null)) {\n    throw Error(`selectAdjacentCell: Row not in table`);\n  }\n  return direction === 'next' ? parentTable.selectNext() : parentTable.selectPrevious();\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nfunction getCorner(rect, cellValue) {\n  let colName;\n  let rowName;\n  if (cellValue.startColumn === rect.minColumn) {\n    colName = 'minColumn';\n  } else if (cellValue.startColumn + cellValue.cell.__colSpan - 1 === rect.maxColumn) {\n    colName = 'maxColumn';\n  } else {\n    return null;\n  }\n  if (cellValue.startRow === rect.minRow) {\n    rowName = 'minRow';\n  } else if (cellValue.startRow + cellValue.cell.__rowSpan - 1 === rect.maxRow) {\n    rowName = 'maxRow';\n  } else {\n    return null;\n  }\n  return [colName, rowName];\n}\nfunction getCornerOrThrow(rect, cellValue) {\n  const corner = getCorner(rect, cellValue);\n  if (!(corner !== null)) {\n    throw Error(`getCornerOrThrow: cell ${cellValue.cell.getKey()} is not at a corner of rect`);\n  }\n  return corner;\n}\nfunction oppositeCorner([colName, rowName]) {\n  return [colName === 'minColumn' ? 'maxColumn' : 'minColumn', rowName === 'minRow' ? 'maxRow' : 'minRow'];\n}\nfunction cellAtCornerOrThrow(tableMap, rect, [colName, rowName]) {\n  const rowNum = rect[rowName];\n  const rowMap = tableMap[rowNum];\n  if (!(rowMap !== undefined)) {\n    throw Error(`cellAtCornerOrThrow: ${rowName} = ${String(rowNum)} missing in tableMap`);\n  }\n  const colNum = rect[colName];\n  const cell = rowMap[colNum];\n  if (!(cell !== undefined)) {\n    throw Error(`cellAtCornerOrThrow: ${colName} = ${String(colNum)} missing in tableMap`);\n  }\n  return cell;\n}\nfunction $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue) {\n  // We are sure that the focus now either contracts or expands the rect\n  // but both the anchor and focus might be moved to ensure a rectangle\n  // given a potentially ragged merge shape\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorCorner = getCorner(rect, anchorCellValue);\n  if (anchorCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, anchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(anchorCorner))];\n  }\n  const newFocusCorner = getCorner(rect, newFocusCellValue);\n  if (newFocusCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newFocusCorner)), cellAtCornerOrThrow(tableMap, rect, newFocusCorner)];\n  }\n  // TODO this doesn't have to be arbitrary, use the closest corner instead\n  const newAnchorCorner = ['minColumn', 'minRow'];\n  return [cellAtCornerOrThrow(tableMap, rect, newAnchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newAnchorCorner))];\n}\nfunction $adjustFocusInDirection(tableObserver, tableMap, anchorCellValue, focusCellValue, direction) {\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, focusCellValue);\n  const spans = $computeTableCellRectSpans(tableMap, rect);\n  const {\n    topSpan,\n    leftSpan,\n    bottomSpan,\n    rightSpan\n  } = spans;\n  const anchorCorner = getCornerOrThrow(rect, anchorCellValue);\n  const [focusColumn, focusRow] = oppositeCorner(anchorCorner);\n  let fCol = rect[focusColumn];\n  let fRow = rect[focusRow];\n  if (direction === 'forward') {\n    fCol += focusColumn === 'maxColumn' ? 1 : leftSpan;\n  } else if (direction === 'backward') {\n    fCol -= focusColumn === 'minColumn' ? 1 : rightSpan;\n  } else if (direction === 'down') {\n    fRow += focusRow === 'maxRow' ? 1 : topSpan;\n  } else if (direction === 'up') {\n    fRow -= focusRow === 'minRow' ? 1 : bottomSpan;\n  }\n  const targetRowMap = tableMap[fRow];\n  if (targetRowMap === undefined) {\n    return false;\n  }\n  const newFocusCellValue = targetRowMap[fCol];\n  if (newFocusCellValue === undefined) {\n    return false;\n  }\n  // We can be certain that anchorCellValue and newFocusCellValue are\n  // contained within the desired selection, but we are not certain if\n  // they need to be expanded or not to maintain a rectangular shape\n  const [finalAnchorCell, finalFocusCell] = $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalAnchorCell.cell);\n  const focusDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalFocusCell.cell);\n  tableObserver.$setAnchorCellForSelection(anchorDOM);\n  tableObserver.$setFocusCellForSelection(focusDOM, true);\n  return true;\n}\nfunction $isSelectionInTable(selection, tableNode) {\n  if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const editorThemeClasses = editor._config.theme;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  addClassNamesToElement(element, editorThemeClasses.tableCellSelected);\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const editorThemeClasses = editor._config.theme;\n  removeClassNamesFromElement(element, editorThemeClasses.tableCellSelected);\n}\nfunction $findCellNode(node) {\n  const cellNode = $findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = $findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $getBlockParentIfFirstNode(node) {\n  for (let prevNode = node, currentNode = node; currentNode !== null; prevNode = currentNode, currentNode = currentNode.getParent()) {\n    if ($isElementNode(currentNode)) {\n      if (currentNode !== prevNode && currentNode.getFirstChild() !== prevNode) {\n        // Not the first child or the initial node\n        return null;\n      } else if (!currentNode.isInline()) {\n        return currentNode;\n      }\n    }\n  }\n  return null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = $getSelection();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ($isRangeSelection(selection)) {\n      if (direction === 'backward') {\n        if (selection.focus.offset > 0) {\n          return false;\n        }\n        const parentNode = $getBlockParentIfFirstNode(selection.focus.getNode());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        if (event.shiftKey) {\n          selection.focus.set(siblingNode.getParentOrThrow().getKey(), siblingNode.getIndexWithinParent(), 'element');\n        } else {\n          siblingNode.selectEnd();\n        }\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        const isTableUnselect = !selection.isCollapsed() && (direction === 'up' && !selection.isBackward() || direction === 'down' && selection.isBackward());\n        if (isTableUnselect) {\n          let focusParentNode = $findMatchingParent(focusNode, n => $isTableNode(n));\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = $findMatchingParent(focusParentNode, $isTableNode);\n          }\n          if (focusParentNode !== tableNode) {\n            return false;\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if (!sibling) {\n            return false;\n          }\n          let newOffset = 0;\n          if (direction === 'up') {\n            if ($isElementNode(sibling)) {\n              newOffset = sibling.getChildrenSize();\n            }\n          }\n          let newFocusNode = sibling;\n          if (direction === 'up') {\n            if ($isElementNode(sibling)) {\n              const lastCell = sibling.getLastChild();\n              newFocusNode = lastCell ? lastCell : sibling;\n              newOffset = $isTextNode(newFocusNode) ? newFocusNode.getTextContentSize() : 0;\n            }\n          }\n          const newSelection = selection.clone();\n          newSelection.focus.set(newFocusNode.getKey(), newOffset, $isTextNode(newFocusNode) ? 'text' : 'element');\n          $setSelection(newSelection);\n          stopEvent(event);\n          return true;\n        } else if ($isRootOrShadowRoot(focusNode)) {\n          const selectedNode = direction === 'up' ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findParentTableCellNodeInTable(tableNode, selectedNode);\n            if (tableCellNode !== null) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.$setAnchorCellForSelection(firstCellDOM);\n              tableObserver.$setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          let focusParentNode = $findMatchingParent(focusNode, n => $isElementNode(n) && !n.isInline());\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = $findMatchingParent(focusParentNode, $isTableNode);\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            stopEvent(event);\n            $setSelection(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    if (direction === 'down' && $isScrollableTablesActive(editor)) {\n      // Enable Firefox workaround\n      tableObserver.setShouldCheckSelection();\n    }\n    return false;\n  }\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n    const anchorCellTable = $findTableNode(anchorCellNode);\n    if (anchorCellTable !== tableNode && anchorCellTable != null) {\n      const anchorCellTableElement = getTableElement(anchorCellTable, editor.getElementByKey(anchorCellTable.getKey()));\n      if (anchorCellTableElement != null) {\n        tableObserver.table = getTable(anchorCellTable, anchorCellTableElement);\n        return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n      }\n    }\n    if (direction === 'backward' || direction === 'forward') {\n      const anchorType = anchor.type;\n      const anchorOffset = anchor.offset;\n      const anchorNode = anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n      const selectedNodes = selection.getNodes();\n      if (selectedNodes.length === 1 && $isDecoratorNode(selectedNodes[0])) {\n        return false;\n      }\n      if (isExitingTableAnchor(anchorType, anchorOffset, anchorNode, direction)) {\n        return $handleTableExit(event, anchorNode, anchorCellNode, tableNode, direction);\n      }\n      return false;\n    }\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n    let edgeSelectionRect;\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = getDOMSelection(getEditorWindow(editor));\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n    if (edgeChild == null) {\n      return false;\n    }\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n    if (edgeChildDOM == null) {\n      return false;\n    }\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n      if (event.shiftKey) {\n        const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n        tableObserver.$setAnchorCellForSelection(cell);\n        tableObserver.$setFocusCellForSelection(cell, true);\n      } else {\n        return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n      }\n      return true;\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    if (!$isTableNode(tableNodeFromSelection)) {\n      throw Error(`$handleArrowKey: TableSelection.getNodes()[0] expected to be TableNode`);\n    }\n    const tableElement = getTableElement(tableNodeFromSelection, editor.getElementByKey(tableNodeFromSelection.getKey()));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.$updateTableTableSelection(selection);\n    const grid = getTable(tableNodeFromSelection, tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.$setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const [tableMap, anchorValue, focusValue] = $computeTableMap(tableNode, anchorCellNode, focusCellNode);\n      return $adjustFocusInDirection(tableObserver, tableMap, anchorValue, focusValue, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction isExitingTableAnchor(type, offset, anchorNode, direction) {\n  return isExitingTableElementAnchor(type, anchorNode, direction) || $isExitingTableTextAnchor(type, offset, anchorNode, direction);\n}\nfunction isExitingTableElementAnchor(type, anchorNode, direction) {\n  return type === 'element' && (direction === 'backward' ? anchorNode.getPreviousSibling() === null : anchorNode.getNextSibling() === null);\n}\nfunction $isExitingTableTextAnchor(type, offset, anchorNode, direction) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return false;\n  }\n  const hasValidOffset = direction === 'backward' ? offset === 0 : offset === anchorNode.getTextContentSize();\n  return type === 'text' && hasValidOffset && (direction === 'backward' ? parentNode.getPreviousSibling() === null : parentNode.getNextSibling() === null);\n}\nfunction $handleTableExit(event, anchorNode, anchorCellNode, tableNode, direction) {\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  if (!isExitingCell(tableMap, cellValue, direction)) {\n    return false;\n  }\n  const toNode = $getExitingToNode(anchorNode, direction, tableNode);\n  if (!toNode || $isTableNode(toNode)) {\n    return false;\n  }\n  stopEvent(event);\n  if (direction === 'backward') {\n    toNode.selectEnd();\n  } else {\n    toNode.selectStart();\n  }\n  return true;\n}\nfunction isExitingCell(tableMap, cellValue, direction) {\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startColumn,\n    startRow\n  } = cellValue;\n  return direction === 'backward' ? startColumn === firstCell.startColumn && startRow === firstCell.startRow : startColumn === lastCell.startColumn && startRow === lastCell.startRow;\n}\nfunction $getExitingToNode(anchorNode, direction, tableNode) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return undefined;\n  }\n  const anchorSibling = direction === 'backward' ? parentNode.getPreviousSibling() : parentNode.getNextSibling();\n  return anchorSibling && $isTableNode(anchorSibling) ? anchorSibling : direction === 'backward' ? tableNode.getPreviousSibling() : tableNode.getNextSibling();\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = $createParagraphNode();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = getDOMSelection(getEditorWindow(editor));\n  if (!domSelection) {\n    return undefined;\n  }\n  const domAnchorNode = domSelection.anchorNode;\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()));\n  // We are only interested in the scenario where the\n  // native selection anchor is:\n  // - at or inside the table's parent DOM\n  // - and NOT at or inside the table DOM\n  // It may be adjacent to the table DOM (e.g. in a wrapper)\n  if (!domAnchorNode || !tableNodeParentDOM || !tableElement || !tableNodeParentDOM.contains(domAnchorNode) || tableElement.contains(domAnchorNode)) {\n    return undefined;\n  }\n  const anchorCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = $findMatchingParent(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\nfunction $getObserverCellFromCellNodeOrThrow(tableObserver, tableCellNode) {\n  const {\n    tableNode\n  } = tableObserver.$lookup();\n  const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n  return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n}\nfunction $getNearestTableCellInTableFromDOMNode(tableNode, startingDOM, editorState) {\n  return $findParentTableCellNodeInTable(tableNode, $getNearestNodeFromDOMNode(startingDOM, editorState));\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction updateColgroup(dom, config, colCount, colWidths) {\n  const colGroup = dom.querySelector('colgroup');\n  if (!colGroup) {\n    return;\n  }\n  const cols = [];\n  for (let i = 0; i < colCount; i++) {\n    const col = document.createElement('col');\n    const width = colWidths && colWidths[i];\n    if (width) {\n      col.style.width = `${width}px`;\n    }\n    cols.push(col);\n  }\n  colGroup.replaceChildren(...cols);\n}\nfunction setRowStriping(dom, config, rowStriping) {\n  if (rowStriping) {\n    addClassNamesToElement(dom, config.theme.tableRowStriping);\n    dom.setAttribute('data-lexical-row-striping', 'true');\n  } else {\n    removeClassNamesFromElement(dom, config.theme.tableRowStriping);\n    dom.removeAttribute('data-lexical-row-striping');\n  }\n}\nconst scrollableEditors = new WeakSet();\nfunction $isScrollableTablesActive(editor = $getEditor()) {\n  return scrollableEditors.has(editor);\n}\nfunction setScrollableTablesActive(editor, active) {\n  if (active) {\n    if (!editor._config.theme.tableScrollableWrapper) {\n      console.warn('TableNode: hasHorizontalScroll is active but theme.tableScrollableWrapper is not defined.');\n    }\n    scrollableEditors.add(editor);\n  } else {\n    scrollableEditors.delete(editor);\n  }\n}\n\n/** @noInheritDoc */\nclass TableNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'table';\n  }\n  getColWidths() {\n    const self = this.getLatest();\n    return self.__colWidths;\n  }\n  setColWidths(colWidths) {\n    const self = this.getWritable();\n    // NOTE: Node properties should be immutable. Freeze to prevent accidental mutation.\n    self.__colWidths = colWidths !== undefined && true ? Object.freeze(colWidths) : colWidths;\n    return self;\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__colWidths = prevNode.__colWidths;\n    this.__rowStriping = prevNode.__rowStriping;\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setRowStriping(serializedNode.rowStriping || false).setColWidths(serializedNode.colWidths);\n  }\n  constructor(key) {\n    super(key);\n    this.__rowStriping = false;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colWidths: this.getColWidths(),\n      rowStriping: this.__rowStriping ? this.__rowStriping : undefined\n    };\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  getDOMSlot(element) {\n    const tableElement = element.nodeName !== 'TABLE' && element.querySelector('table') || element;\n    if (!(tableElement.nodeName === 'TABLE')) {\n      throw Error(`TableNode.getDOMSlot: createDOM() did not return a table`);\n    }\n    return super.getDOMSlot(tableElement).withAfter(tableElement.querySelector('colgroup'));\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    const colGroup = document.createElement('colgroup');\n    tableElement.appendChild(colGroup);\n    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());\n    setDOMUnmanaged(colGroup);\n    addClassNamesToElement(tableElement, config.theme.table);\n    if (this.__rowStriping) {\n      setRowStriping(tableElement, config, true);\n    }\n    if ($isScrollableTablesActive(editor)) {\n      const wrapperElement = document.createElement('div');\n      const classes = config.theme.tableScrollableWrapper;\n      if (classes) {\n        addClassNamesToElement(wrapperElement, classes);\n      } else {\n        wrapperElement.style.cssText = 'overflow-x: auto;';\n      }\n      wrapperElement.appendChild(tableElement);\n      return wrapperElement;\n    }\n    return tableElement;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__rowStriping !== this.__rowStriping) {\n      setRowStriping(dom, config, this.__rowStriping);\n    }\n    updateColgroup(dom, config, this.getColumnCount(), this.getColWidths());\n    return false;\n  }\n  exportDOM(editor) {\n    const superExport = super.exportDOM(editor);\n    const {\n      element\n    } = superExport;\n    return {\n      after: tableElement => {\n        if (superExport.after) {\n          tableElement = superExport.after(tableElement);\n        }\n        if (isHTMLElement$1(tableElement) && tableElement.nodeName !== 'TABLE') {\n          tableElement = tableElement.querySelector('table');\n        }\n        if (!isHTMLElement$1(tableElement)) {\n          return null;\n        }\n\n        // Scan the table map to build a map of table cell key to the columns it needs\n        const [tableMap] = $computeTableMapSkipCellCheck(this, null, null);\n        const cellValues = new Map();\n        for (const mapRow of tableMap) {\n          for (const mapValue of mapRow) {\n            const key = mapValue.cell.getKey();\n            if (!cellValues.has(key)) {\n              cellValues.set(key, {\n                colSpan: mapValue.cell.getColSpan(),\n                startColumn: mapValue.startColumn\n              });\n            }\n          }\n        }\n\n        // scan the DOM to find the table cell keys that were used and mark those columns\n        const knownColumns = new Set();\n        for (const cellDOM of tableElement.querySelectorAll(':scope > tr > [data-temporary-table-cell-lexical-key]')) {\n          const key = cellDOM.getAttribute('data-temporary-table-cell-lexical-key');\n          if (key) {\n            const cellSpan = cellValues.get(key);\n            cellDOM.removeAttribute('data-temporary-table-cell-lexical-key');\n            if (cellSpan) {\n              cellValues.delete(key);\n              for (let i = 0; i < cellSpan.colSpan; i++) {\n                knownColumns.add(i + cellSpan.startColumn);\n              }\n            }\n          }\n        }\n\n        // Compute the colgroup and columns in the export\n        const colGroup = tableElement.querySelector(':scope > colgroup');\n        if (colGroup) {\n          // Only include the <col /> for rows that are in the output\n          const cols = Array.from(tableElement.querySelectorAll(':scope > colgroup > col')).filter((dom, i) => knownColumns.has(i));\n          colGroup.replaceChildren(...cols);\n        }\n\n        // Wrap direct descendant rows in a tbody for export\n        const rows = tableElement.querySelectorAll(':scope > tr');\n        if (rows.length > 0) {\n          const tBody = document.createElement('tbody');\n          for (const row of rows) {\n            tBody.appendChild(row);\n          }\n          tableElement.append(tBody);\n        }\n        return tableElement;\n      },\n      element: isHTMLElement$1(element) && element.nodeName !== 'TABLE' ? element.querySelector('table') : element\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      for (let x = 0; x < row.length; x++) {\n        const cell = row[x];\n        if (cell == null) {\n          continue;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestTableCellInTableFromDOMNode(this, elem);\n        if (cellNode !== null && tableCellNode.is(cellNode)) {\n          return {\n            x,\n            y\n          };\n        }\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = $getNearestNodeFromDOMNode(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  getRowStriping() {\n    return Boolean(this.getLatest().__rowStriping);\n  }\n  setRowStriping(newRowStriping) {\n    const self = this.getWritable();\n    self.__rowStriping = newRowStriping;\n    return self;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  getColumnCount() {\n    const firstRow = this.getFirstChild();\n    if (!firstRow) {\n      return 0;\n    }\n    let columnCount = 0;\n    firstRow.getChildren().forEach(cell => {\n      if ($isTableCellNode(cell)) {\n        columnCount += cell.getColSpan();\n      }\n    });\n    return columnCount;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (!(tableElement !== null)) {\n    throw Error(`$getElementForTableNode: Table Element Not Found`);\n  }\n  return getTable(tableNode, tableElement);\n}\nfunction $convertTableElement(domNode) {\n  const tableNode = $createTableNode();\n  if (domNode.hasAttribute('data-lexical-row-striping')) {\n    tableNode.setRowStriping(true);\n  }\n  const colGroup = domNode.querySelector(':scope > colgroup');\n  if (colGroup) {\n    let columns = [];\n    for (const col of colGroup.querySelectorAll(':scope > col')) {\n      let width = col.style.width || '';\n      if (!PIXEL_VALUE_REG_EXP.test(width)) {\n        // Also support deprecated width attribute for google docs\n        width = col.getAttribute('width') || '';\n        if (!/^\\d+$/.test(width)) {\n          columns = undefined;\n          break;\n        }\n      }\n      columns.push(parseFloat(width));\n    }\n    if (columns) {\n      tableNode.setColWidths(columns);\n    }\n  }\n  return {\n    after: children => $descendantsMatching(children, $isTableRowNode),\n    node: tableNode\n  };\n}\nfunction $createTableNode() {\n  return $applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $insertTableCommandListener({\n  rows,\n  columns,\n  includeHeaders\n}) {\n  const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);\n  $insertNodeToNearestRoot(tableNode);\n  const firstDescendant = tableNode.getFirstDescendant();\n  if ($isTextNode(firstDescendant)) {\n    firstDescendant.select();\n  }\n  return true;\n}\nfunction $tableCellTransform(node) {\n  if (!$isTableRowNode(node.getParent())) {\n    // TableCellNode must be a child of TableRowNode.\n    node.remove();\n  } else if (node.isEmpty()) {\n    // TableCellNode should never be empty\n    node.append($createParagraphNode());\n  }\n}\nfunction $tableRowTransform(node) {\n  if (!$isTableNode(node.getParent())) {\n    // TableRowNode must be a child of TableNode.\n    // TODO: Future support of tbody/thead/tfoot may change this\n    node.remove();\n  } else {\n    $unwrapAndFilterDescendants(node, $isTableCellNode);\n  }\n}\nfunction $tableTransform(node) {\n  // TableRowNode is the only valid child for TableNode\n  // TODO: Future support of tbody/thead/tfoot/caption may change this\n  $unwrapAndFilterDescendants(node, $isTableRowNode);\n  const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);\n  const maxRowLength = gridMap.reduce((curLength, row) => {\n    return Math.max(curLength, row.length);\n  }, 0);\n  const rowNodes = node.getChildren();\n  for (let i = 0; i < gridMap.length; ++i) {\n    const rowNode = rowNodes[i];\n    if (!rowNode) {\n      continue;\n    }\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`TablePlugin: Expecting all children of TableNode to be TableRowNode, found ${rowNode.constructor.name} (type ${rowNode.getType()})`);\n    }\n    const rowLength = gridMap[i].reduce((acc, cell) => cell ? 1 + acc : acc, 0);\n    if (rowLength === maxRowLength) {\n      continue;\n    }\n    for (let j = rowLength; j < maxRowLength; ++j) {\n      // TODO: inherit header state from another header or body\n      const newCell = $createTableCellNode();\n      newCell.append($createParagraphNode());\n      rowNode.append(newCell);\n    }\n  }\n}\n\n/**\n * Register a transform to ensure that all TableCellNode have a colSpan and rowSpan of 1.\n * This should only be registered when you do not want to support merged cells.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTableCellUnmergeTransform(editor) {\n  return editor.registerNodeTransform(TableCellNode, node => {\n    if (node.getColSpan() > 1 || node.getRowSpan() > 1) {\n      // When we have rowSpan we have to map the entire Table to understand where the new Cells\n      // fit best; let's analyze all Cells at once to save us from further transform iterations\n      const [,, gridNode] = $getNodeTriplet(node);\n      const [gridMap] = $computeTableMap(gridNode, node, node);\n      // TODO this function expects Tables to be normalized. Look into this once it exists\n      const rowsCount = gridMap.length;\n      const columnsCount = gridMap[0].length;\n      let row = gridNode.getFirstChild();\n      if (!$isTableRowNode(row)) {\n        throw Error(`Expected TableNode first child to be a RowNode`);\n      }\n      const unmerged = [];\n      for (let i = 0; i < rowsCount; i++) {\n        if (i !== 0) {\n          row = row.getNextSibling();\n          if (!$isTableRowNode(row)) {\n            throw Error(`Expected TableNode first child to be a RowNode`);\n          }\n        }\n        let lastRowCell = null;\n        for (let j = 0; j < columnsCount; j++) {\n          const cellMap = gridMap[i][j];\n          const cell = cellMap.cell;\n          if (cellMap.startRow === i && cellMap.startColumn === j) {\n            lastRowCell = cell;\n            unmerged.push(cell);\n          } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {\n            if (!$isTableCellNode(cell)) {\n              throw Error(`Expected TableNode cell to be a TableCellNode`);\n            }\n            const newCell = $createTableCellNode(cell.__headerState);\n            if (lastRowCell !== null) {\n              lastRowCell.insertAfter(newCell);\n            } else {\n              $insertFirst$1(row, newCell);\n            }\n          }\n        }\n      }\n      for (const cell of unmerged) {\n        cell.setColSpan(1);\n        cell.setRowSpan(1);\n      }\n    }\n  });\n}\nfunction registerTableSelectionObserver(editor, hasTabHandler = true) {\n  const tableSelections = new Map();\n  const initializeTableNode = (tableNode, nodeKey, dom) => {\n    const tableElement = getTableElement(tableNode, dom);\n    const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);\n    tableSelections.set(nodeKey, [tableSelection, tableElement]);\n  };\n  const unregisterMutationListener = editor.registerMutationListener(TableNode, nodeMutations => {\n    editor.getEditorState().read(() => {\n      for (const [nodeKey, mutation] of nodeMutations) {\n        const tableSelection = tableSelections.get(nodeKey);\n        if (mutation === 'created' || mutation === 'updated') {\n          const {\n            tableNode,\n            tableElement\n          } = $getTableAndElementByKey(nodeKey);\n          if (tableSelection === undefined) {\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          } else if (tableElement !== tableSelection[1]) {\n            // The update created a new DOM node, destroy the existing TableObserver\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          }\n        } else if (mutation === 'destroyed') {\n          if (tableSelection !== undefined) {\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n          }\n        }\n      }\n    }, {\n      editor\n    });\n  }, {\n    skipInitialization: false\n  });\n  return () => {\n    unregisterMutationListener();\n    // Hook might be called multiple times so cleaning up tables listeners as well,\n    // as it'll be reinitialized during recurring call\n    for (const [, [tableSelection]] of tableSelections) {\n      tableSelection.removeListeners();\n    }\n  };\n}\n\n/**\n * Register the INSERT_TABLE_COMMAND listener and the table integrity transforms. The\n * table selection observer should be registered separately after this with\n * {@link registerTableSelectionObserver}.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTablePlugin(editor) {\n  if (!editor.hasNodes([TableNode])) {\n    {\n      throw Error(`TablePlugin: TableNode is not registered on editor`);\n    }\n  }\n  return mergeRegister(editor.registerCommand(INSERT_TABLE_COMMAND, $insertTableCommandListener, COMMAND_PRIORITY_EDITOR), editor.registerNodeTransform(TableNode, $tableTransform), editor.registerNodeTransform(TableRowNode, $tableRowTransform), editor.registerNodeTransform(TableCellNode, $tableCellTransform));\n}\n\nexport { $computeTableMap, $computeTableMapSkipCellCheck, $createTableCellNode, $createTableNode, $createTableNodeWithDimensions, $createTableRowNode, $createTableSelection, $deleteTableColumn, $deleteTableColumn__EXPERIMENTAL, $deleteTableRow__EXPERIMENTAL, $findCellNode, $findTableNode, $getElementForTableNode, $getNodeTriplet, $getTableAndElementByKey, $getTableCellNodeFromLexicalNode, $getTableCellNodeRect, $getTableColumnIndexFromTableCellNode, $getTableNodeFromLexicalNodeOrThrow, $getTableRowIndexFromTableCellNode, $getTableRowNodeFromTableCellNodeOrThrow, $insertTableColumn, $insertTableColumn__EXPERIMENTAL, $insertTableRow, $insertTableRow__EXPERIMENTAL, $isScrollableTablesActive, $isTableCellNode, $isTableNode, $isTableRowNode, $isTableSelection, $removeTableRowAtIndex, $unmergeCell, INSERT_TABLE_COMMAND, TableCellHeaderStates, TableCellNode, TableNode, TableObserver, TableRowNode, applyTableHandlers, getDOMCellFromTarget, getTableElement, getTableObserverFromTableElement, registerTableCellUnmergeTransform, registerTablePlugin, registerTableSelectionObserver, setScrollableTablesActive };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes } from '@lexical/html';\nimport { $isLinkNode } from '@lexical/link';\nimport { $isMarkNode } from '@lexical/mark';\nimport { $isTableSelection } from '@lexical/table';\nimport { $getSelection, $getRoot, $isRangeSelection, $isNodeSelection, $isElementNode, $isTextNode, $isParagraphNode, COMMAND_PRIORITY_CRITICAL } from 'lexical';\nimport { forwardRef, useState, useRef, useCallback, useEffect, useMemo } from 'react';\nimport { jsxs, jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({\n  '\\t': '\\\\t',\n  '\\n': '\\\\n'\n});\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'), 'g');\nconst SYMBOLS = Object.freeze({\n  ancestorHasNextSibling: '|',\n  ancestorIsLastChild: ' ',\n  hasNextSibling: '',\n  isLastChild: '',\n  selectedChar: '^',\n  selectedLine: '>'\n});\nconst FORMAT_PREDICATES = [node => node.hasFormat('bold') && 'Bold', node => node.hasFormat('code') && 'Code', node => node.hasFormat('italic') && 'Italic', node => node.hasFormat('strikethrough') && 'Strikethrough', node => node.hasFormat('subscript') && 'Subscript', node => node.hasFormat('superscript') && 'Superscript', node => node.hasFormat('underline') && 'Underline'];\nconst FORMAT_PREDICATES_PARAGRAPH = [node => node.hasTextFormat('bold') && 'Bold', node => node.hasTextFormat('code') && 'Code', node => node.hasTextFormat('italic') && 'Italic', node => node.hasTextFormat('strikethrough') && 'Strikethrough', node => node.hasTextFormat('subscript') && 'Subscript', node => node.hasTextFormat('superscript') && 'Superscript', node => node.hasTextFormat('underline') && 'Underline'];\nconst DETAIL_PREDICATES = [node => node.isDirectionless() && 'Directionless', node => node.isUnmergeable() && 'Unmergeable'];\nconst MODE_PREDICATES = [node => node.isToken() && 'Token', node => node.isSegmented() && 'Segmented'];\nfunction generateContent(editor, commandsLog, exportDOM, customPrintNode, obfuscateText = false) {\n  const editorState = editor.getEditorState();\n  const editorConfig = editor._config;\n  const compositionKey = editor._compositionKey;\n  const editable = editor._editable;\n  if (exportDOM) {\n    let htmlString = '';\n    editorState.read(() => {\n      htmlString = printPrettyHTML($generateHtmlFromNodes(editor));\n    });\n    return htmlString;\n  }\n  let res = ' root\\n';\n  const selectionString = editorState.read(() => {\n    const selection = $getSelection();\n    visitTree($getRoot(), (node, indent) => {\n      const nodeKey = node.getKey();\n      const nodeKeyDisplay = `(${nodeKey})`;\n      const typeDisplay = node.getType() || '';\n      const isSelected = node.isSelected();\n      res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(' ')} ${nodeKeyDisplay} ${typeDisplay} ${printNode(node, customPrintNode, obfuscateText)}\\n`;\n      res += $printSelectedCharsLine({\n        indent,\n        isSelected,\n        node,\n        nodeKeyDisplay,\n        selection,\n        typeDisplay\n      });\n    });\n    return selection === null ? ': null' : $isRangeSelection(selection) ? printRangeSelection(selection) : $isTableSelection(selection) ? printTableSelection(selection) : printNodeSelection(selection);\n  });\n  res += '\\n selection' + selectionString;\n  res += '\\n\\n commands:';\n  if (commandsLog.length) {\n    for (const {\n      index,\n      type,\n      payload\n    } of commandsLog) {\n      res += `\\n   ${index}. { type: ${type}, payload: ${payload instanceof Event ? payload.constructor.name : payload} }`;\n    }\n  } else {\n    res += '\\n   None dispatched.';\n  }\n  const {\n    version\n  } = editor.constructor;\n  res += `\\n\\n editor${version ? ` (v${version})` : ''}:`;\n  res += `\\n   namespace ${editorConfig.namespace}`;\n  if (compositionKey !== null) {\n    res += `\\n   compositionKey ${compositionKey}`;\n  }\n  res += `\\n   editable ${String(editable)}`;\n  return res;\n}\nfunction printRangeSelection(selection) {\n  let res = '';\n  const formatText = printFormatProperties(selection);\n  res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''} ${selection.style !== '' ? `{ style: ${selection.style} } ` : ''}`;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  res += `\\n   anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? 'null' : anchorOffset}, type: ${anchor.type} }`;\n  res += `\\n   focus { key: ${focus.key}, offset: ${focusOffset === null ? 'null' : focusOffset}, type: ${focus.type} }`;\n  return res;\n}\nfunction printNodeSelection(selection) {\n  if (!$isNodeSelection(selection)) {\n    return '';\n  }\n  return `: node\\n   [${Array.from(selection._nodes).join(', ')}]`;\n}\nfunction printTableSelection(selection) {\n  return `: table\\n   { table: ${selection.tableKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;\n}\nfunction visitTree(currentNode, visitor, indent = []) {\n  const childNodes = currentNode.getChildren();\n  const childNodesLength = childNodes.length;\n  childNodes.forEach((childNode, i) => {\n    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));\n    if ($isElementNode(childNode)) {\n      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));\n    }\n  });\n}\nfunction normalize(text, obfuscateText = false) {\n  const textToPrint = Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, 'g'), String(value)), text);\n  if (obfuscateText) {\n    return textToPrint.replace(/[^\\s]/g, '*');\n  }\n  return textToPrint;\n}\nfunction printNode(node, customPrintNode, obfuscateText = false) {\n  const customPrint = customPrintNode ? customPrintNode(node, obfuscateText) : undefined;\n  if (customPrint !== undefined && customPrint.length > 0) {\n    return customPrint;\n  }\n  if ($isTextNode(node)) {\n    const text = node.getTextContent();\n    const title = text.length === 0 ? '(empty)' : `\"${normalize(text, obfuscateText)}\"`;\n    const properties = printAllTextNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if ($isLinkNode(node)) {\n    const link = node.getURL();\n    const title = link.length === 0 ? '(empty)' : `\"${normalize(link, obfuscateText)}\"`;\n    const properties = printAllLinkNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if ($isMarkNode(node)) {\n    return `ids: [ ${node.getIDs().join(', ')} ]`;\n  } else if ($isParagraphNode(node)) {\n    const formatText = printTextFormatProperties(node);\n    let paragraphData = formatText !== '' ? `{ ${formatText} }` : '';\n    paragraphData += node.__style ? `(${node.__style})` : '';\n    return paragraphData;\n  } else {\n    return '';\n  }\n}\nfunction printTextFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES_PARAGRAPH.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printAllTextNodeProperties(node) {\n  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node)].filter(Boolean).join(', ');\n}\nfunction printAllLinkNodeProperties(node) {\n  return [printTargetProperties(node), printRelProperties(node), printTitleProperties(node)].filter(Boolean).join(', ');\n}\nfunction printDetailProperties(nodeOrSelection) {\n  let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'detail: ' + str;\n  }\n  return str;\n}\nfunction printModeProperties(nodeOrSelection) {\n  let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'mode: ' + str;\n  }\n  return str;\n}\nfunction printFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printTargetProperties(node) {\n  let str = node.getTarget();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'target: ' + str;\n  }\n  return str;\n}\nfunction printRelProperties(node) {\n  let str = node.getRel();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'rel: ' + str;\n  }\n  return str;\n}\nfunction printTitleProperties(node) {\n  let str = node.getTitle();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'title: ' + str;\n  }\n  return str;\n}\nfunction $printSelectedCharsLine({\n  indent,\n  isSelected,\n  node,\n  nodeKeyDisplay,\n  selection,\n  typeDisplay\n}) {\n  // No selection or node is not selected.\n  if (!$isTextNode(node) || !$isRangeSelection(selection) || !isSelected || $isElementNode(node)) {\n    return '';\n  }\n\n  // No selected characters.\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  if (node.getTextContent() === '' || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {\n    return '';\n  }\n  const [start, end] = $getSelectionStartEnd(node, selection);\n  if (start === end) {\n    return '';\n  }\n  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;\n  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];\n  const unselectedChars = Array(start + 1).fill(' ');\n  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);\n  const paddingLength = typeDisplay.length + 2; // 1 for the space after + 1 for the double quote.\n\n  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(' ');\n  return [SYMBOLS.selectedLine, indentionChars.join(' '), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join('')].join(' ') + '\\n';\n}\nfunction printPrettyHTML(str) {\n  const div = document.createElement('div');\n  div.innerHTML = str.trim();\n  return prettifyHTML(div, 0).innerHTML;\n}\nfunction prettifyHTML(node, level) {\n  const indentBefore = new Array(level++ + 1).join('  ');\n  const indentAfter = new Array(level - 1).join('  ');\n  let textNode;\n  for (let i = 0; i < node.children.length; i++) {\n    textNode = document.createTextNode('\\n' + indentBefore);\n    node.insertBefore(textNode, node.children[i]);\n    prettifyHTML(node.children[i], level);\n    if (node.lastElementChild === node.children[i]) {\n      textNode = document.createTextNode('\\n' + indentAfter);\n      node.appendChild(textNode);\n    }\n  }\n  return node;\n}\nfunction $getSelectionStartEnd(node, selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if ($isNodeSelection(selection) || anchorAndFocus === null) {\n    return [-1, -1];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const textContent = node.getTextContent();\n  const textLength = textContent.length;\n  let start = -1;\n  let end = -1;\n\n  // Only one node is being selected.\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {\n      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];\n    } else if (node === anchorNode) {\n      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];\n    } else if (node === focusNode) {\n      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];\n    } else {\n      // Node is within selection but not the anchor nor focus.\n      [start, end] = [0, textLength];\n    }\n  }\n\n  // Account for non-single width characters.\n  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LARGE_EDITOR_STATE_SIZE = 1000;\nconst TreeView = /*#__PURE__*/forwardRef(function TreeViewWrapped({\n  treeTypeButtonClassName,\n  timeTravelButtonClassName,\n  timeTravelPanelSliderClassName,\n  timeTravelPanelButtonClassName,\n  viewClassName,\n  timeTravelPanelClassName,\n  editorState,\n  setEditorState,\n  setEditorReadOnly,\n  generateContent\n}, ref) {\n  const [timeStampedEditorStates, setTimeStampedEditorStates] = useState([]);\n  const [content, setContent] = useState('');\n  const [timeTravelEnabled, setTimeTravelEnabled] = useState(false);\n  const [showExportDOM, setShowExportDOM] = useState(false);\n  const playingIndexRef = useRef(0);\n  const inputRef = useRef(null);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [isLimited, setIsLimited] = useState(false);\n  const [showLimited, setShowLimited] = useState(false);\n  const lastEditorStateRef = useRef();\n  const lastGenerationID = useRef(0);\n  const generateTree = useCallback(exportDOM => {\n    const myID = ++lastGenerationID.current;\n    generateContent(exportDOM).then(treeText => {\n      if (myID === lastGenerationID.current) {\n        setContent(treeText);\n      }\n    }).catch(err => {\n      if (myID === lastGenerationID.current) {\n        setContent(`Error rendering tree: ${err.message}\\n\\nStack:\\n${err.stack}`);\n      }\n    });\n  }, [generateContent]);\n  useEffect(() => {\n    if (!showLimited && editorState._nodeMap.size > LARGE_EDITOR_STATE_SIZE) {\n      setIsLimited(true);\n      if (!showLimited) {\n        return;\n      }\n    }\n\n    // Prevent re-rendering if the editor state hasn't changed\n    if (lastEditorStateRef.current !== editorState) {\n      lastEditorStateRef.current = editorState;\n      generateTree(showExportDOM);\n      if (!timeTravelEnabled) {\n        setTimeStampedEditorStates(currentEditorStates => [...currentEditorStates, [Date.now(), editorState]]);\n      }\n    }\n  }, [editorState, generateTree, showExportDOM, showLimited, timeTravelEnabled]);\n  const totalEditorStates = timeStampedEditorStates.length;\n  useEffect(() => {\n    if (isPlaying) {\n      let timeoutId;\n      const play = () => {\n        const currentIndex = playingIndexRef.current;\n        if (currentIndex === totalEditorStates - 1) {\n          setIsPlaying(false);\n          return;\n        }\n        const currentTime = timeStampedEditorStates[currentIndex][0];\n        const nextTime = timeStampedEditorStates[currentIndex + 1][0];\n        const timeDiff = nextTime - currentTime;\n        timeoutId = setTimeout(() => {\n          playingIndexRef.current++;\n          const index = playingIndexRef.current;\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          setEditorState(timeStampedEditorStates[index][1]);\n          play();\n        }, timeDiff);\n      };\n      play();\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n  }, [timeStampedEditorStates, isPlaying, totalEditorStates, setEditorState]);\n  const handleExportModeToggleClick = () => {\n    generateTree(!showExportDOM);\n    setShowExportDOM(!showExportDOM);\n  };\n  return /*#__PURE__*/jsxs(\"div\", {\n    className: viewClassName,\n    children: [!showLimited && isLimited ? /*#__PURE__*/jsxs(\"div\", {\n      style: {\n        padding: 20\n      },\n      children: [/*#__PURE__*/jsx(\"span\", {\n        style: {\n          marginRight: 20\n        },\n        children: \"Detected large EditorState, this can impact debugging performance.\"\n      }), /*#__PURE__*/jsx(\"button\", {\n        onClick: () => {\n          setShowLimited(true);\n        },\n        style: {\n          background: 'transparent',\n          border: '1px solid white',\n          color: 'white',\n          cursor: 'pointer',\n          padding: 5\n        },\n        children: \"Show full tree\"\n      })]\n    }) : null, !showLimited ? /*#__PURE__*/jsx(\"button\", {\n      onClick: () => handleExportModeToggleClick(),\n      className: treeTypeButtonClassName,\n      type: \"button\",\n      children: showExportDOM ? 'Tree' : 'Export DOM'\n    }) : null, !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2 && /*#__PURE__*/jsx(\"button\", {\n      onClick: () => {\n        setEditorReadOnly(true);\n        playingIndexRef.current = totalEditorStates - 1;\n        setTimeTravelEnabled(true);\n      },\n      className: timeTravelButtonClassName,\n      type: \"button\",\n      children: \"Time Travel\"\n    }), (showLimited || !isLimited) && /*#__PURE__*/jsx(\"pre\", {\n      ref: ref,\n      children: content\n    }), timeTravelEnabled && (showLimited || !isLimited) && /*#__PURE__*/jsxs(\"div\", {\n      className: timeTravelPanelClassName,\n      children: [/*#__PURE__*/jsx(\"button\", {\n        className: timeTravelPanelButtonClassName,\n        onClick: () => {\n          if (playingIndexRef.current === totalEditorStates - 1) {\n            playingIndexRef.current = 1;\n          }\n          setIsPlaying(!isPlaying);\n        },\n        type: \"button\",\n        children: isPlaying ? 'Pause' : 'Play'\n      }), /*#__PURE__*/jsx(\"input\", {\n        className: timeTravelPanelSliderClassName,\n        ref: inputRef,\n        onChange: event => {\n          const editorStateIndex = Number(event.target.value);\n          const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];\n          if (timeStampedEditorState) {\n            playingIndexRef.current = editorStateIndex;\n            setEditorState(timeStampedEditorState[1]);\n          }\n        },\n        type: \"range\",\n        min: \"1\",\n        max: totalEditorStates - 1\n      }), /*#__PURE__*/jsx(\"button\", {\n        className: timeTravelPanelButtonClassName,\n        onClick: () => {\n          setEditorReadOnly(false);\n          const index = timeStampedEditorStates.length - 1;\n          const timeStampedEditorState = timeStampedEditorStates[index];\n          setEditorState(timeStampedEditorState[1]);\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          setTimeTravelEnabled(false);\n          setIsPlaying(false);\n        },\n        type: \"button\",\n        children: \"Exit\"\n      })]\n    })]\n  });\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerLexicalCommandLogger(editor, setLoggedCommands) {\n  const unregisterCommandListeners = new Set();\n  let i = 0;\n  for (const [command] of editor._commands) {\n    unregisterCommandListeners.add(editor.registerCommand(command, payload => {\n      setLoggedCommands(state => {\n        i += 1;\n        const newState = [...state];\n        newState.push({\n          index: i,\n          payload,\n          type: command.type ? command.type : 'UNKNOWN'\n        });\n        if (newState.length > 10) {\n          newState.shift();\n        }\n        return newState;\n      });\n      return false;\n    }, COMMAND_PRIORITY_CRITICAL));\n  }\n  return () => unregisterCommandListeners.forEach(unregister => unregister());\n}\nfunction useLexicalCommandsLog(editor) {\n  const [loggedCommands, setLoggedCommands] = useState([]);\n  useEffect(() => {\n    return registerLexicalCommandLogger(editor, setLoggedCommands);\n  }, [editor]);\n  return useMemo(() => loggedCommands, [loggedCommands]);\n}\n\nexport { TreeView, generateContent, registerLexicalCommandLogger, useLexicalCommandsLog };\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { useLexicalCommandsLog, TreeView as TreeView$1, generateContent } from '@lexical/devtools-core';\nimport { mergeRegister } from '@lexical/utils';\nimport * as React from 'react';\nimport { useState, useEffect } from 'react';\nimport { jsx } from 'react/jsx-runtime';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction TreeView({\n  treeTypeButtonClassName,\n  timeTravelButtonClassName,\n  timeTravelPanelSliderClassName,\n  timeTravelPanelButtonClassName,\n  timeTravelPanelClassName,\n  viewClassName,\n  editor,\n  customPrintNode\n}) {\n  const treeElementRef = /*#__PURE__*/React.createRef();\n  const [editorCurrentState, setEditorCurrentState] = useState(editor.getEditorState());\n  const commandsLog = useLexicalCommandsLog(editor);\n  useEffect(() => {\n    // Registers listeners to update the tree view when the editor state changes\n    return mergeRegister(editor.registerUpdateListener(({\n      editorState\n    }) => {\n      setEditorCurrentState(editorState);\n    }), editor.registerEditableListener(() => {\n      setEditorCurrentState(editor.getEditorState());\n    }));\n  }, [editor]);\n  useEffect(() => {\n    const element = treeElementRef.current;\n    if (element !== null) {\n      // Assigns the editor instance to the tree view DOM element for internal tracking\n      // @ts-ignore Internal field used by Lexical\n      element.__lexicalEditor = editor;\n      return () => {\n        // Cleans up the reference when the component is unmounted\n        // @ts-ignore Internal field used by Lexical\n        element.__lexicalEditor = null;\n      };\n    }\n  }, [editor, treeElementRef]);\n\n  /**\n   * Handles toggling the readonly state of the editor.\n   *\n   * @param {boolean} isReadonly - Whether the editor should be set to readonly.\n   */\n  const handleEditorReadOnly = isReadonly => {\n    const rootElement = editor.getRootElement();\n    if (rootElement == null) {\n      return;\n    }\n    rootElement.contentEditable = isReadonly ? 'false' : 'true';\n  };\n  return /*#__PURE__*/jsx(TreeView$1, {\n    treeTypeButtonClassName: treeTypeButtonClassName,\n    timeTravelButtonClassName: timeTravelButtonClassName,\n    timeTravelPanelSliderClassName: timeTravelPanelSliderClassName,\n    timeTravelPanelButtonClassName: timeTravelPanelButtonClassName,\n    viewClassName: viewClassName,\n    timeTravelPanelClassName: timeTravelPanelClassName,\n    setEditorReadOnly: handleEditorReadOnly,\n    editorState: editorCurrentState,\n    setEditorState: state => editor.setEditorState(state),\n    generateContent: async function (exportDOM) {\n      // Generates the content for the tree view, allowing customization with exportDOM and customPrintNode\n      return generateContent(editor, commandsLog, exportDOM, customPrintNode);\n    },\n    ref: treeElementRef\n  });\n}\n\nexport { TreeView };\n"],
  "mappings": "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",
  "names": ["generateContent", "import_react", "import_jsx_runtime", "TreeView"]
}
